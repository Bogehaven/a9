Hu~l g (R~~ LD~:( iI,.,. c.o,.__ q:>\jh s~ e.--~ 3 C.C1.-~cto'loo<) Verification by 111odel checking pc.ts l'-t:Y-!~i 3.1 Motivation for verification There is a great advantage in being able to verify the correctness of computer systems (whether they are hardware, software, or a combination). This is most obvious in the case of safety-critical systems, but also applies to those that are commercially critical, snch as mass-produced chips, mission critical, etc. Formal verification methods have quite recently become usable by industry and there is a growing demand for professionals able to apply them (witness recent job adverts by BT, Intel, National Semiconductor Corp, etc.). In this chapter, and the next one, we examine two applications of logics to the question of verifying the correctness of computer systems, or programs. (Formal) verification techniques can be thought of as comprising three parts: 0 A fimnework for modelling systems, typically a description language or s0111e sort; e A specification language for describing the properties to be verified: o A verification method to establish whether the description of a system satisfies the specification. Approaches to verification can be classified according to the following criteria: Proof-based vs. model-based. ln a proof-based approach, the system description is a set of formulas r (in a suitable logic) and the specification is another formula 4,.The verification method consists of trying to find n proof that f' f-4,.This typically requires guidance and expertise from the user. [n a model-based approach, the system is represented by a finite 148 model JI resented b computing automatic, bility. In Chap often soun (semantic, models Ji, approach i is based or them. Degree of automa Extremes 2 assisted tee Full-vs. property-1 erty of the typically e: Intended domain o qnential or is one whic (e.g. opera Pre-vs. post-devel• early in the lier on in t Intel lost n FDIV erro This chapter co: terms of the abm based, property-ve reactive systems a currency bugs are of running several non-reproduceablc can help one to fi1 By contrast, Cl which in terms oft property-verificati, we expect to term ang rrectness of computer Jination). This is most applies to those that ;, mission critical, etc. ,1e usable by industry J apply them (witness or Corp, etc.). In this ions of logics to the 111s,or progrmns. • as comprising three ,cription language of s to be verified; cription of a system ling to the following h, the system descripnd the specification is 1sists of trying to find tidance and expertise :presented by a finite 3.1 Motivation for verification model JI for an appropriate logic. The specification is again represented by a formnla ef,and the verification method consists of computing whether a model JI satisfies ,p(Jt I=cf,).This is usually automatic, though the restriction to finite models limits the applicability. In Chapters 1 and 2, we could see that logical proof systems are often sound and complete, meaning that f' f--cf,(provability) iff f' I=cf, (semantic entailment), where the latter is 'defined as follows: for all models JI, if Jt I=f', then Jt I=ef,.Thus, we see that the model-based approach is potentially simpler than the proof-based approach, for it is based on a single model Jt rather than a possibly infinite class of them. Degree of automation. Approaches differ on how automatic the method is. Extremes are fully automatic and fully manual, with many computerassisted techniques somewhere in the middle. Full-vs. property-verificatio11.The specification may describe a single property of the system, or it may describe its full behaviour. The latter is typically expensive to verify. Intended domain of application, which may be hardware or software; sequential or concurrent; reactive or terminating; etc. A reactive system is one which reacts to its environment and is not meant to terminate (e.g. operating systems, embedded systems and computer hardware). Pre-vs. post-development.Verification is of greater advantage if introduced early in the course of system development, because errors caught earlier on in the production cycle are less costly to rectify. (Apparently, Intel lost millions of dollars by releasing their Pentium chip with the FDIV error.) This chapter concerns a verification method called model checking. In the terms of the above classification, model checking is an automatic, modelbased, property-verification approach. It is intended to be used for concurrent, reactive systems and originated as a post-development methodology. Concurrency bugs are among the most difficult to find by testing (the activity or running several simulations of important scenarios), since they tend to be non-reproduceable, so it is well worth having a verification technique that can help one to find them. By contrast, Chapter 4 describes a very different verification technique which in terms of the above classification is a proof-based, computer-assisted, property-verification approach. It is intended to be used for programs which we expect to terminate and produce a result. Model checking is based on temporal logic. The idea of temporal logic is that a formula is not statically trne or false in a model, as it is in propositional and predicate logic. Instead, the models of temporal logic contain several states and a fonnnla can be trne in some states· and false in others. Tims, the static notion of trnth is replaced by a dynamic one, in which the formulas may change their trnth values as the system evolves from state to state. In model checking, the models vft are transition systems and the properties ¢ are formulas in temporal logic. To verify that a system satisfies a property. we must do three things: 0 Model the system using the description language of a model checker. arriving at a model At. 0 Code the property using the specification language of the model checker. resulting in a temporal logic formula ¢. 0 Run the model checker with inputs vft and ¢. The model checker outputs the answer 'yes' if JI I=¢ and 'no' otherwise; in the latter case, most model checkers also produce a trace of system behaviour which causes this failure. This automatic generation of such 'counter traces' is an important tool in the design and debugging of systems. Since model checking is a model-based approach, in terms of the classification given earlier, it follows that in this chapter, unlike in the previous two, we will not be concerned with semantic entaihnent (r I= ¢ ), or with proof theory (I' 1-¢ ), such as the development of a natural deduction calculus for temporal logic. We will work solely with the notion of satisfaction, i.e. the satisfaction relation between a model and a fomrnla (At I=¢ ). There is a whole zoo of temporal logics that people have proposed and used for vaiious things. The abnndance of such formalisms may be organised by classifying them according to their patiicularview of'time'. Linear-time logics think of time as a chain of time instances, branching-timelogics offer several alternative future worlds at any given point of time; the latter is most useful in modelling non-deterministic systems or computations. Another quality of 'time' is whether we think of it as being continuous or discrete. The former would be suggested if we study an analogue computer, the latter might be preferred for a synchronous network. In this chapter, we study a logic where 'time' is branching and discrete. Such a logic has a modal aspect to it since the possible future paths of computations allow us to speak of 'possibilities' and 'necessities'; the study of such modalities is the focus of Chapter 5. The logic we now study is called computation tree logic (CTL), due to E. Clarke and E. A. Emerson. This logic has proven to be extremely fruitful in vetifying hardware and communication pre the ve1ification of s answer to the ques of some logic, .ft the underlying satis which we define in i 'system'. You should not c Models are abstract which are irrelevant that one does in ca pe1:fectcircles, or E very powerful, for t concern. Models of the kin advantage that we r science as having t a unified approach networks, software, states. They could b, language, or actual example, the states second kind of corn underlying computa terms of state transi, as a state transition same values for vari: than that of s. You variety of ways, bm entirety as a binary We write s -, s' to e from state s in one c The expressive p, is generally more ti For example, if we running on a single t of temporal logic , it is in propositional logic contain severa(' e in others. Thus, the' L which the fonnulas '. ·om state to state. In and the properties </i 1 satisfies a property, of a model checker, >f the model checker, .nd 'no' otherwise; in : of system behaviour such 'counter traces' ,terns. !rms of the classificain the previous two, •F <f,), or with proof eduction calculus for f satisfaction, i.e. the IIF<f,). veproposed and used may be organised by 1e'.Linear-time logics ,e logics offer several , latter is most useful s. Another quality of discrete. The former ·, the latter might be mching and discrete. ;ib]e future paths of tecessities'; the study gic we now study is and E. A. Emerson. ifying hardware and 3.1 Motivation for verification •communication protocols; and people are beginning to apply it even to 'the verification of software. Model checking is the process of computing an answer to the question of whether JI, s F <f,holds, where <f,is a formula some logic, JI! an appropriate model, s a state of that model and F the underlying satisfaction relation. Of course, <f,is now a formula of CTL, which we define in a little while, and the model ✓ti is a representation of our 'system'. You should not confuse such models .,II with an actual physical system. Models are abstractions that omit lots of real features of a physical system, which are irrelevant to the checking of <f,.This is similar to the abstractions that one does in calculus or mechanics. There we talk about straight lines, pe1:fectcircles, or an experiment without friction. These abstractions are very powerful, for they allow us to focus on the essentials of our particular concern. Models of the kind we have in mind are very general indeed. That has the advantage that we may think of a wide spectrum of structures in computer science as having the same type of model. So this allows us to develop a unified approach of model checking for the verification of hardware, networks, software, etc. The fundamental constituents of such models are states.They could be the current values of variables in a C-like programming language, or actual states of physical devices in a network architecture, for example, the states 'busy' and 'available' of some computing resource. The second kind of constituents of these models expresses the dynamics of the underlying computational process. Such dynamical behaviour is captured in terms of state transitions.Thus, one may think of an assignment statement X := x+ 1; as a state transition from state s to state s', where the latter state stores the same values for variables as s, but for x, in which it stores a value one bigger than that of s. You may think of the set of possible state transitions in a variety of ways, but it is best for our purposes to think of them in their entirety as a binary relation -> on the set of states S: --> £ S XS. We write s --> s' to express that it is possible for the system to reach state s' from state s in one computation step. The expressive power of such models stems from the fact that there is generally more than one possible successor state from a given state s. For example, if we have a °language with parallel assignment statements running on a single processor, then we expect to encounter multiple future Verffication by model checking computation paths depending on the actual scheduler of this parallel activity. See Figure 3.2 (later) for a pictorial representation of such a model. 3.2 The syntax of comp11tation tree logic Computation tree logic, or CTL for short, is a temporal logic, having connectives that allow us to refer to the future. It is also a branching-time logic. meaning that its model of time is a tree-like structure in which the future is not determined; there are different paths in the future, any one of which might be the 'actual' path that is realised. We work with a fixed set of atomic fonnulas/descliptions (such as p, q, r, ... , or Pl, p2, ... ). These atoms stand for atomic descriptions of a system, like The printer is busy. or 111ere are currently no requested jobs for the printer. or The current content of register Rl is the integer value 6. and the choice of atomic descriptions obviously depends on our particular interest in a system at hand. Definition 3.1 We define CTL formulas inductively via a Backus Naur form (as done for the other logics of Chapters 1 and 2): cf>::= _LI T IP I ( •'P)I (<f,I\ <p)I ( cf,V <p)I ( ef,-> cf>)I AX 'PI EX ef,I A[¢ U cf>]I E[r/> U r,b]I AG 4,I EG ¢ I AF rf,IEF ¢. where p ranges over atomic formulas/descriptions. Thus, the symbols T and J_ are CTL formulas, as are all atomic descriptions; ,</Jis a CTL formula if rf,is one, etc. We will look at the meaning of these formulas, especially the connectives that did not occur in Chapter 1, in the next section; for now, we concentrate on their syntax. The connectives A.,'(, EX, AG, EG, AU, EU, AF and EF are called temporal connectives. Notice that each of the CTL temporal connectives is a pair of symbols. The first of the pair is one of A and E. A means 'along All paths' (inevitably) and E means 'along at least (there Exists) one path' (possibly). The second one of the pair is X, F, G, or U, meaning 'neXt state', 'some Future state', 'all future states (i E[</J1U ¢2], for e symbols X. F, G a E; similarly, every Convention3.2 W to what we did fo (consisting of , EX) bind most tig --,., AU and EU. Naturally, we u some examples of not well-formed, i are atomic formul • EGr; e AG(q-> EGr) according to tt (EGr) o A[r U q] e EFE[r U q] e A[p U EFr] • EFEGp---+ AF EF (EG p ---+AI o AGAFr e A[/11 U A[p2 U o E[A[p1 U p2]U e AG (p---+ A[p U It is worth spend construct each of o FGr -since F e A,G,p o F[r U q] o EF(r U q) o AEFr e AF[(rUq)/\(f It is especially wo construct these. F tis parallel activity. 1 a model. logic, having con:mchinb0 -time Ionic"' ' which the future any one of which riptions (such as descriptions of a inter. alue 6. m our particular 1ckus Naur form A.X<J>I EX</JI lFq>. atomic descripthe meaning of in Chapter 1, in The connectives Jra/ connectives. Jf symbols. The ths' (inevitably) ly). The second ,e Future state', 3.2 The syntax of computation tree logic 'all future states (Globally)' and Until, respectively. The pair of operators in E[</J1 U ¢2], for example, is EU. Notice that AU and EU are binary. The symbols X, F, G and U cannot occur without being preceded by an A or an E; similarly, every A or E must have one of X, F, G and U to accompany it. Convention 3.2 We assume similar binding priorities for the CTL connectives to what we did for propositional and predicate logic. The unary connectives (consisting of, and the temporal connectives AG, EG, AF, EF, AX and EX) bind most tightly. Next in the order come /\ and V; and after that come ->, AU and EU. Naturally, we use brackets in order to override these priorities. Let us see some examples of well-formed CTL formulas and some examples which are not well-formed, in order to understand the syntax. Suppose that p, q and r are atomic formulas. The following are well-fo1med CTL formulas: e EGr; e AG(q--+ EGr) -note that this is not the same as AGq--+ EGr, for according to the binding priorities the latter formnla means (AGq) --+ (EG1·) e A[r U q] " EF E[r U q] e A[p U EFr] e EFEGp--+ AFr (again, note that this binds as (EFEGp)--+ AFr, not EF(EGp--+ AFr) or EFEG(p--+ AFr)!) e AGAFr " A[p1 U A[p2 U p3]] e E[A[p1 U pz] U p3] e AG(p--+ A[p U (,p /\ A[,p U ql)]). It is worth spending some time seeing how the syntax rules allow us to construct each of these. The following are not well-fo1med formulas: " FG r -since F and G must occur immediately after an E or an A e A,G,p e F[r U q] "EF(rUq) e AEFr ., AF [(r U q) /\ (p Ur)]. It is especially worth nnderstanding why the syntax rules don't allow us to construct these. For example, take BF (r U q). EF is an operator and so is Verification by model checking U, so why is this not a well-formed CTL formula? The answer is that U can occur only when paired with an A or an E. The E we have is paired with the F. To make this into a well-formed CTL formula, we would have to write EFE[r U q] or EFA[r U q]. Notice that we use square brackets after the A or E, when the paired operator is a U. There is no strong reason for this; you could use ordinary round brackets instead. However, it often helps one to read the formula (because we can more easily spot where the corresponding close bracket is). Another reason for using the square brackets is that a particular model checker called SMV, which we will study later in this chapter, adopts this notation. The reason AF [(r U q) /\ (p U r)] is not a well-formed formula is that the syntax does not allow us to put a boolean connective (like /\) directly inside A[] or E[ ]. Occurrences of A or E must be followed by one of G, F, X or U; when they are followed by U, it must be in the form A[<f, U 1/JJ. Now, the <f,and the 1Pmay contain /\, since they are arbitrary formulas; so A[(p I\ q) U (-,r--+ q)] is a well-formed formula. Fig.3.1. Th, Observe that AU and EU are binary connectives which mix infix and prefix notation. In pure infix, we would write <f,1 AU <f,2, whereas in pure * (a) FGrprefix we would write AU( ¢1, ¢2). (b) XXrAs with any formal language, and as we did in the previous two chapters, (c) A-,Qit is useful to draw parse trees for well-formed formulas. The parse tree for (d) F[r UA[AX -,p U E[EX (p I\ q) U -,p]] is shown in Figure 3.1. (e) EXX * (f) AEF1Definition3.3 A subformula of a CTL formula <f,is any formula 1p whose * (g) AF [(1parse tree is a subtree of <f,'s parse tree. 3. State which EXERCISES3.1 those which We let {p,q,r,s,t} be the set of propositional atoms for all systems of this not well-forr set of exercises. (a) -,(-,p: 1. Write the parse trees for the following CTL formulas: (b) Xq * (c) -,AX * (a) EGr (d) p U (,* (b) AG(q-> EGr) * (e) E[(N* (c) A[p U EFr] * (f) (Fr) I• (d) EF EG p-+ AF r (recall Convention 3.2) (g) -,(AC(e) A[p U A[q Ur]] * 4. List all subf(f) E[A[p U q] U r] q])]).(g) AG(p-> A[p U (-,p I\A[-,p U q])]). 2. Explain why the following are not well-formed CTL formulas: mswer is that U can ve is paired with the would have to w1ite E, when the paired could use ordinary o read the formula 1ding close bracket a particular model :hapter, adopts this 1ed formula is that ve (like /\) directly owed by one of G, he form A[¢ U ,p]. itrary fo1mulas; so !iich mix infix and 2, whereas in pure rious two chapters, The parse tree for fo1mula ,p whose tll systems of this lS: formulas: 3.2 The syntax of computation tree logic AU I\ p q Fig. 3.1. The parse tree of a CTL formula without infix notation. * (a) FGr (b) XXr (c) A,G,p (d) F[r U q] (e) EXXr * (f) AEFr * (g) AF [(r U q) /\ (p Ur)]. 3. State which of the strings below are well-formed CTL formulas. For those which are well-formed, draw the parse tree. For those which are not well-formed, explain why not. (a) ,(,p)V(r/\s) (b) Xq * (c) ,AXq (d) p U (AX_l_) * (e) E[(AXq) U (,(,p) V (T /\ s))] * (f) (Fr)/\ (AG q) (g) ,(AGq)V(EGq). * 4. List all subformulas of the formula AG (p -+ A[p U (,p I\ A[,p V q])]). Verification by model checking 3.3 Semantics of compntation tree logic Definition 3.4 A model ./It= (S, -+, L) for CTL is a set of states S endowed with a transition relation ---+ (a binary relation on S), such that every s ES has some s' E S withs---->s', and a labelling function L: S ---+&'(Atoms). This definition looks rather mathematical; but it simply means that you have a collection of states S, a relation ---+, saying how the system can move from state to state, and, associated with each state s, you have the set of atomic propositions L(s) which are true at that particular state. We write &'(Atoms) for the power set of Atoms, a collection of atomic descriptions. For example, the power set of {p,q} is {(i),{p}, { q}, {p,q} }. A good way of thinking about L is that it is just an assignment of truth values to all the propositional atoms as it was the case for propositional logic (we called that a valuation). The difference now is that we have more than one state, so this assignment depends on which states the system is in: L(s) contains all atoms which are true in state s. We may conveniently express all the information about a (finite) model Ji for CTL using directed graphs whose nodes (= the states) contain all propositional atoms that are true in that state. For example, if our system has only three states s0, s1 and s2; if the only possible transitions between states are so ---->s1, so -+ s2, s1 -> so, s1 -+ s2 and s2 ---> s2; and if L(so) ~ {p, q }, L(si) ~ {q, r) and L(s2) ~ {r},then we can condense all this information into the picture in Fignre 3.2. We prefer to present models by means of such pictures whenever that is feasible. The requirement that for every s E S there is at least one s' E S such that s -+ s' means that no state of the system can 'deadlock'. This is no severe restriction, because we can always add an extra state sd representing deadlock, together with new transitions s -+ sd for each s which was a deadlock in the old system, as well as s,1 -+ s,1. See Figure 3.3 for such an example. Let us define the intended meanings of the CTL connectives. Definition 3.5 Let .JI= (S,-,,L) be a model for CTL. Given any sin S, we define whether a CTL formula </>holds in state s. We denote this by Jt, s I=¢. Naturally, the definition of the satisfaction relation I= is done by structural induction on all CTL formulas: Fig.3.2. A concise nre states containi11 state. so .--<~ ( "'--._./~ ',.~, s1 Fig.3.3. On the left transitions. On the no state can dead! 'deadlock' state cor 1. Jt,sl= Ta 2. jf,s I=p ifl 3. j/, s I=~<I> 4. .Jl,s I=</>1, 5. .ti, s I=</>11 6. .ii, s I=</>1• 7. Ji,s I=AX AX says:' 8. .11,s I=EX of states S endowed. uch that every s E S, ply means that you' he system can movet' 1ou have the set 1lar state. We write.' 1tomic descriptions. }}. A good way of th values to all the ogic (we called that ,m one state, so this ) contains all atoms ,ut a (finite) model states) contain all le, if our system has ions between states d if L(so) ~ {p, q }, 11 this information s by means of such ,t one s' E S such 1dlock'. This is no ate sd representing ch s which was a •re 3.3 for such an ~tives. ven any sin S, we ote this by lone by structural 3.3 Semantics of computation rree logic S3S3 no state can deadlock; of course, it is then our understanding that reaching the 'deadlock' state corresponds to deadlock in the original system. l. .,tt,s FT and J!,s ljlJ_ for alls ES. 2. ..!!,s F p iff p E L(s). 3. .it, s F ,<{>iff Ji, s ljl<{>. 4. .i!,s I= <{> iff J!,s and .11,s F </>2.1 /I cpz F </>1 5. .ii, s F efJ1V c/32iff .l/, s F </>1 or j/, s F </32. 6. .JI, s F 'Pl--> cfa2iff JI, s lj"ef,1 or .!!, s I= ,/32. 7. JI, s F AX 1>ifffor all s1 such that s ~, s1 we have .,tt, s1 I= q\. Thus, AX says: 'in every next state'. 8. .II, s F EX<{> ifffor some s1 such thats ~, s1we have .//, s1F qJ.Thus, Verification by model checking EX says: 'in some next state'. E is dual to A -in exactly the same way that 3 is dual to 't in predicate logic. 9. At, s I=AG <j,holds iff for all paths s1--+ s2 --+ s3 --,. ... , where s1equals s, and all s; along the path, we have Ji, s; I=<f,.Mnemonically: for All computation paths beginning in s the property <j,holds Globally. Note that 'along the path' includes the path's initial state s. 10. Jt, s I=EG ,pholds iff there is a path s1 -> s2 ---->s3 --+ ... , where s1 equals s, and for all s; along the path, we have ..ll, s; I=<j,.Mnemonically: there Exists a path beginning in s such that <j,holds Globally along the path. 11. Jt,s I=AF <j,holds iff for all paths s1 -> s2 -> ... ,where s1 equals s, there is some s; such that JI!, s; I=<j,.Mnemonically: for All computation paths beginning in s there will be some Future state where <p holds. 12. ✓It, s I=EF <j,holds iff there is a path s1 -> s2 -> s3 -> ... , where s1 equals s, and for some s; along the path, we have JI, s; I= ¢. Mnemonically: there Exists a compntation path beginning in s such that ¢ holds in some Future state; 13. JI, s I=A[¢1 U </Jz]holds iff for all paths s1 -> s2 ---+ s3 -> ... , where s1 equals s, that path satisfies ¢ 1U ¢2, i.e. there is some s; along the path, such that Jl,s; F <f,2, and, for each j < i, we have Jlt,sj I=¢1. Mnemonically: All computation paths beginning in s satisfy that <j,1 Until <J,2holds on it. 14. Jt,s I= E[q',1 U ¢2] holds iff there is a path s1 -> s2 -> s3 -> ... , where s1 equals s, and that path satisfies ¢1 U ¢2 as specified in 13. Mnemonically: there Exists a computation path beginning in s such that ¢1 Until ¢2 holds on it. For the remainder of this section, we will be concerned with the computational consequences of this definition, and with justifying and explaining its clauses. The first six clauses are exactly what we expect from our knowledge of propositional logic gained in Chapter 1. Notice that, for example, the truth value of ,,f, in a state depends on the truth value of ¢ in the same state. This contrasts with the clauses for AX and EX. The truth value of AX¢ in a state s is determined not by the truth value of ¢ in s, but by ¢ in states that are related to s by the relation ---+;ifs --+ s, then this value also depends on the truth value of <j,in s. The next four clauses also exhibit this phenomenon, except more so: for example, to determine the truth value of AG¢ involves looking at the trnth Fig. 3.4. Unwinding t paths beginning in a J value of¢ not only : states as well. In fa value of ¢ in every the current state. Clauses 9-14 abu \]seful to visualise a unwinding the tran whence 'computatio state satisfies a CTL Figure 3.2 for the de Figure 3.4. The diagrams in F states satisfy the fo: course, we could ad the satisfaction -a illustrate a 'least' wa Remark3.6 Notice t 1 If this task is done by a visualisation of a system in exactly the same + ... , where s1 equals . Mnemonically: for ty cpholds Globally. tial state s. "*s3 ......),... , where s1 4't,s; F ¢. Mnemontat ¢ holds Globally ., where s1 equals s, ally: for All compu'uture state where cp --+ s3 --+ ... , where we have .4't,s; F ¢. beginning in s such 2 ~ s3 ~ ... , where is some s; along the we have ./lt,sj F ¢1. ; in s satisfy that cp1 ~S2~S3~ ... , •2 as specified in 13. beginning in s such I with the computag and explaining its a our knowledge of r example, the truth p in the same state. th value of AX</>in ,, but by cpin states ; value also depends except more so: for looking at the truth A 1593.3 Semantics of computation tree logic S1 8S2 q,r ~ '\ so p,q Fig.3.4. Unwinding the system of Figure 3.2 as an infinite tree of all computation paths beginning in a particular state. value of ¢ not only in the immediately related states, but in indirectly related states as well. In fact, in the case of AG¢, you have to examine the truth value of ¢ in every state related by any number of forward links of -> to the current state. Clauses 9-14 above refer to computation paths in models. It is therefore 1,1sefulto visualise all possible computation paths from a given state s by unwinding the transition system to obtain an infinite computation tree, whence 'computation tree logic'. This greatly facilitates deciding whether a state satisfies a CTL formula 1. For example, if we unwind the state graph of Figure 3.2 for the designated starting state so,then we get the infinite tree in Figure 3.4. The diagrams in Figures 3.5-3.8 show schematically systems whose starting states satisfy the formulas EF q,,EG ¢, AG cp and AF¢, respectively. Of course, we could add more cpto any of these diagrams and still preserve the satisfaction -although there is nothing to add for AG. The diagrams illustrate a 'least' way of satisfying the formulas. Remark 3.6 Notice that, in clauses 9-14 above, the future includes the present. 1 If this task is done by a computer, then that is a different matter, but we seem to benefit from this visualisation of a system as a tree. Vcr(fication by model checking 0 Fig. 3.5. A system whose starting state satisfies EF </>. Fig. 3.6. A system whose starting state satisfies EG </>. This means that, when we say 'in all future states', we are including the present state as a future state. It is a matter of convention whether we do this, or not; see the exercises below for an exclusiveversion of CTL. A consequence of adopting the convention that the future shall include the present is that the formulas (AG p) -> p, p -+ A[q U p] and p -+ EF p are true in every state of every model. Fig. 3.; Fig. 3.: stands for 'until'. holds continuo1 actually demands ti for <f,1 to hold conI the states s3 to s9 s, ) fies EF q,. es EG q,. : inclnding the present hether we do this, or CTL. A consequence :le the present is that Fp are true in every 3.3 Semantics of computation tree logic q, q, q, q, </> q, Fig. 3.7. A system whose starting state satisfies AG q,. q, q, Fig. 3.8. A system whose starting state satisfies AF q,. We now move our discussion to the clauses for AU and EU. The symbol U stands for 'until'. The formula </>1U ¢2 holds on a path if it is the case that ,J,rholds continuously until the next occurrence of ¢z. Moreover, ¢1 U ¢2 actually demands that ¢2 do~s hold in some future state, i.e. it is not enough for <j,1 to hold continuously forever. See Figure 3.9 for illustration: each of the states s3 to s9 satisfies p U q along the path shown, but so to s2 don't. Verification by model checking -•1 ~ ~ ~ ~ % ~ -~ •w qp Fig. 3.9. An illustration of the meaning of Until in the semantics of CTL. Each of the states s3 to s9 satisfiesp U q along the path shown. Thus, we defined earlier that a particular path so --+ s1 -> s2 --+ ... satisfies </i1U </,2iff: ® there is some s; along the path, such that s; F </,2,and ® for each j < i, we have Sj F ef,1. The clauses for AU and EU given in Definition 3.5 reflect this intuition, for all paths and some path, respectively. Note that the semantics of <t,1U </,2is not saying anything about </,1 in state s;; neither does it say anything abont ef,2 in states Sj with j < i. This might be in contrast to some of the implicit meanings of 'until' in natural language usage. For example, in the sentence 'I smoked until I was 22.' it is not only expressed that the person referred to continually smoked up until he, or she, was 22 years old, but we also would interpret such a sentence as saying that this person gave up smoking from that point onwards. This is different from the semantics of Until in temporal logic. It should be clear that we have outlined the formal foundations of a procedure that, given </,,./II and s, can check whether ./It, s F </, holds. In particular, if the given set of states is finite, then we may compute the set of all states satisfying </,.If the model J/t is clear from the context,· we will simply write s F </,instead of Jlt, s F </,.Let us now look at some example checks for the system in Figures 3.2 and 3.4. 1. J/t, so I=p /\ q holds since the atomic symbols p and q are contained in the node of s0. 2. J!, s0 F ,,. holds since the atomic symbol r is not contained in node< SQ. 3. J/f, so F T holds by definition. 4. JI, so F EX (q /\r) holds since we have the leftmost computation path so-, s1 ->so-, s1 -> ... in Figure 3.4, whose second node s1 contains, q and r. 5. .JI, so F ,AX (q /\ r) holds since we have the rightmost computation•, •1 ( ~ path so...., s: only contain 6. Jt, so F ,EF in so such th: so, because t p and,-hold 7. Jl,s2 F BG computation holds in all fi 8. Jl,s2 F AGr beginning in 9. Jt,so F AFr the system re, 10. Jl,so F E[(pl path so --+ s2 (i = 1) satisfi satisfy p /\ q. 11. Jl,so I=A[p l successor stat beginning in .s XERCISES 3.2 (elet {p,q,r,t} bet: rexercises. 1. Consider the s ,antics of CTL. Each of 11 --> s2 ---+ ... satisfies d tlect this intnition, for nantics of ¢1 U ef>2is it say anything about , some of the implicit mple, in the sentence :he person referred to Id, but we also would tve up smoking from ; of Until in temporal ml foundations of a 1en we may compute iar from the context, 1s now look at some and q are contained ot contained in node >st computation path ond node s1 contains :htmost computation 3.3 Semantics of computation tree logic St Fig. 3.10. A system with four states. path so --> s2 --> s2 -> s2 ---+ ... in Figure 3.4, whose second node s2 only contains r, but not q. 6. Jt, soF ~EF (p/\r) holds since there is no compntation path beginning in so such that we could reach a state where p I\ r would hold. This is so, because there is simply no state whatsoever in this system, where p and r hold at the same time. 7. Jt, s2 I= EG r (note the s2 instead of so!) holds since there is a computation path s2 --> s2 --> s2 -> . . . beginning in s2 such that r holds in all future states. 8. J!t, s2 F AG r holds as well, since there is only one computation path beginning in s2 and it satisfies r globally. 9. Jt, so F AF r holds since, for all computation paths beginning in so, the system reaches a state (s1 or s2) such that r holds. 10. j/,s 0 F E[(p/\q) Ur] holds since we have the rightmost computation path so -+ s2 --> s2 -> s2 -,. . . . in Figure 3.4, whose second node s2 (i = 1) satisfies r, but all previous nodes ( only j = 0, i.e. node so) satisfy p I\ q. 11. Jt,so I=A[p Ur] holds since p holds at so and r holds in any possible successor state of so, so p U r is true for all computation paths beginning in so (so we may choose i = 1 independently of the path). EXERCISES 3.2 We let {p, q, r, t} be the set of propositional atoms for all systems of this set of exercises. 1. Consider the system .,If in Figure 3.10. Verification by model checking So (a) Beginning from state so, unwind this system into an infinite tree, and draw all computation paths up to length 4 ( = the first four layers of that tree). (b) Make the following checks JI, s0 I=</>,where </>is listed below. For that you need to explain why the check holds, or what reasons there are for its failure: ,,, (i) ,p ---+ I' (ii) AF t *(iii) ,EGr (iv) E(t U q) (v) AF q (vi) EF q (vii) EG r (viii) AG(r V q). (c) Make the same checks as in (b) but now for state s2. 2. Consider the following system jf in Figure 3.11. Check the following CTL formulas </>for state so, i.e. determine whether Jt, so I=</>holds: (a) AF q (b) AG(EF (p V r)) (c) EX(EXr) (d) AG(AFq). 3. Do the same as in exercise 2, but for state s2. 4. The meaning of the temporal operators AU, EU, AG, EG, AF and EF was defined to be such that 'the present includes the future'. For example, EF pis true for a state if pis trne for that state already. Often one would like corresponding operators such that the future excludes the presen to defines What kind of pn CTL? We list a : include some wo: the following pro It is possible t hold: E F ( started /\ • For any state, i be acknowledg AG (requested A certain proc, AG (AF enabl, • • Whatever hapr locked: AF (AG dead I• • From any state AG (EF restar An upwards ti direction when AG (floor=2 /\ Here, our aton variables, e.g. fl The elevator ca AG (floor=3 /\ i EXERCISES 3.3 * 1. Express in amount of occurs unt 2. Explain in patterns al plain Engl tes. rstem into an infinite p to length 4 (= the 1ere ¢ is listed below. :heck holds, or what for state s2. . Check the following ther At,so t=¢ holds: U, AG, EG, AF and ,ludes the future'. For tt state already. Often at the fi1ture excludes 3.3 Semantics (~r computaliOll tree logic the present. Use suitable connectives of the grammar in Definition 3.1 to define such (six) modified connectives as derived operators in CTL. 3.3.1 P,·acticrllpatten1s of specijic11tio11s What kind of practically relevant properties can we check with formulas of CTL? We list a few of the common patterns. Suppose atomic descriptions include some words such as busy and requested. We may require some of the following properties of real systems: • It is possible to get to a state where started holds. but ready does not hold: EF (started/\ ,ready). • For any state, ifa request (of some resource) occurs. then it will eventually be acknowledged: AG (requested -+ AF aclmowledgecl). • A certain process is enabled infinitely often on every computation path: AG (AF enabled). • Whatever happens, a certain process will eventually be permanently deadlocked: AF (AG deadlock). • From any state it is possible to get to a restart state: AG (EF restart). • An upwards travelling elevator ai the second floor does not change its direction when it has passengers wishing to go to the fifth floor: AG (floor=2 /\ direction=up /\ ButtonPressed5 -> A[direction=up U floor=5]) Here, our atomic descriptions are boolean expressions built from system variables, e.g. floor=2. • The elevator can remain idle on the third floor with its doors closed: AG (floor=3 /\idle/\ door=closed -+ EG (floor=3 /\idle/\ door=closed)). EXERCISES 3.3 * 1. Express in CTL: Whenever p is followed by q (after some finite amount of steps), then the system enters an 'interval' in which no ,occurs until t. 2. Explain in detail why the CTL formulas for the practical specification patterns above capture the stated 'informal' properties expressed in plain English. Verification by model checking 3. Consider the CTL formula AG (p -, AF (s /\ AX (AF t))). Explain what exactly it expresses in terms of the order of occurrence of events p, sand t. 4. Write down a CTL formula which says that p precedes s and t on all computation paths; you may find it easier to code the negation of that specification first. 5. Represent 'After p, q is never true.' as a CTL formula, where this constraint is meant to apply on all computation paths. 6. Find a CTL formula which expresses the following property on all computation paths: (a) 'Between the events q and r, pis never true.' (b) 'Transitions to states satisfying p occur at most twice.'. 3.3.2 lmp01·ta11t equivale11ces between CTL formulas Definition3.7 Two CTL formulas ¢ and 1Pare said to be semantically equiPalent if any state in any model which satisfies one of them also satisfies the other; we denote this by ¢ = 1p. Note that we wrote¢ = 1Pin Chapter 1 if the propositional logic formulas ¢ and 1Phad the same meaning no matter what valuation (= assignment of ; truth values) one considers. We may think of such valuations as L(s) for a CTL model with one state s and one transition s -> s. Therefore, we see how< the definition above extends the meaning of = to a larger class of models)· and formulas. We have already noticed that A is a universal quantifier on paths and E is the corresponding existential quantifier. Moreover, G and F are also: universal and existential quantifiers, ranging over the states along a particular path. In view of these facts, it is not surprising to find that de Morgan rules. exist for A and E and also F and G: --.AF¢ -EG --.4> --.EF</> -AG --.if>. On any particular path, each state has a unique successor. Therefore, X is. its own dual on computation paths and we have We also have tb AFq • Yon can check thi ef,1 U ¢2 to be tru true at some futnr In the expression , true in every state state). Naturally, any , hold in CTL. Thii e.g. we have that _scheme ¢ V --.,t,of propositional logic example, in Chapt of connectives, sin terms of those thn This is also tht written --.EX --. by of AU and EU , --.AF--.if>(using (3 E[T U ¢]. Therefc : connectives. Also EG, EU, ar A[¢ ;.'This equivalence is illater (Section 3.8 Similarly, AG, A adequate sets, but • \s~t consisting of Al (reduces to EG, EU •X are adequate_, mantical/y equiv, 3.3 Semantics of computation tree logic X (AF t))). Explain ccurrence of events recedes s and t on )de the negation of Jrmula, where this aths. ng property on all nost twice.'. •r,1111/as semantically equivm also satisfies the onal logic formulas 1 ( = assigmneut of . tions as L(s) for a :refore, we see how ;er class of models ifier on paths and G and F are also ; along a particular tt de Morgan mies (3.1) . or. Therefore, X is (3.2) We also have the equivalences AFrj, = A[TUq,] EF </>= E[T U ,{>]. You can check this by looking back at the meaning of the clause for U. For 'PI U rpz to be true in a state along a path, it is necessary that rj,2 become true at some future point and that 4>1is true in every state until that point. In the expression above, we let q,1 be T, so that the requirement that rj,1 be true in every state until q,2 is vacuously satisfied ( since T is true in every state). Naturally, any equivalence which holds in propositional logic will also hold in CTL. This is true even if the equivalence involves CTL formulas: e.g. we have that T and (AXp) V ,AXp are equivalent since the formula scheme ef, V ,rp of propositional logic is equivalent to T. Therefore, as in propositional logic, there is some redundancy among the connectives. For example, in Chapter 1 we saw that the set {1-, /\, ,} forms an adequate set of connectives, since the other connectives V, -+, T, etc., can be written in terms of those three. ( Cf. exercise 3, page 71.) This is also the case in CTL. Moreover, the connective AX can be written ,EX, by (3.2); and AG, AF, EG and EF can be written in terms of AU and EU as follows: first, write AG rj, as ,EF ,ef, and EG rj, as ,AF ,q, (using (3.1)) and then use AF rj, = A[T U rj,] and EF ,f, = E[T U rj,]. Therefore AU, EU and EX form an adequate set of temporal connectives . Also EG, EU, and EX form an adequate set, for we have the equivalence A[rj, U 1/J] = ,(E[ •1/J U ( ,rp I\ ,v.1)]VEG ,1p ). (3.3) This equivalence is rather harder to demonstrate than the others; we will do it later (Section 3.8.1). Similarly, AG, AU and AX form an adequate set. There are many other adequate sets, but we just mention one more, since we will use it later: the set consisting of AF, EU and EX. Since AF can be reduced to EG, this set reduces to EG, EU and EX which we have seen to be adequate . Theorem 3.8 The set of operators 1-, , and I\ together with AF, EU and EX are adequate for CTL: any CTL formula can be transformed into a semantically equivalent CTL formula which uses only those logical connectives. Verification by model checking Some other noteworthy equivalences in CTL are the following: AG,j, -,j,I\ A,'{ AG <f, EG<J, -cpl\ EXEG,b AF <J,-q,VAXAF<f, EF,j, -¢ V EX EF ¢ A[</, U v,] -1pV (</,I\ AXA[</, U 1pl) E[<J, U v;] -1pV (¢/\EXE[¢ U 1pl). For example, the intuition for the third one is the following: in order to have AF <J,in a particular state, ¢ must be true at some point along each path from that state. To achieve this, we either have <(,true now, in the current state; or we postpone it, in which case we must have AF<(,in each of the next states. Notice how this equivalence appears to define AF in terms of A,'( and AF itself -an apparently circular definition. In fact, these equivalences can be used to define the six connectives on the left in terms of AX and EX, in a llOn-circularway. This is called the fixed-point characterisation of CTL; it is the mathematical foundation for the model-checking algorithm developed in Section 3.5; and we return to it later (Section 3.9). EXERCISES 3.4 1. Which of the following pairs of CTL formulas are equivalent? For those which are not, exhibit a model of one of the pair which is not a model of the other. (a) EF ¢ and EG ¢ ,:, (b) EF q,V EF 1pand EF ( q\V 1p) ,:, (c) AF ef,V AF,p and AF(¢ V 1p) (d) AF ,<f,and ,EG <f, ,:, (e) EF ,¢ and ,AF q, (f) A[</,1 U A[r/Jz U rf,3]]and A[A[,J,1 U </J2]U ¢1] (Hint: it might make it simpler if you think first about models that have just one·path.) (g) T and AG q,-+ EG <f, ,:, (h) T and EG ¢ -+ AG¢. 2. Find operators to replace the ? marks, to make the following equivalences. (a) EF,q, = ,??</> *(b) AG(<j,/\1p) = AGrj,?AG,p. 3. Use the definition of I=between states and CTL formulas to explain why s I=AG AF¢ means that ¢ is true infinitely often along every . path starting at s. 4. Prove the l * , Write pse takes as in: equivalent ( J_, ,, !\, Al Let us now look a with mutual exclw a file on a disk or do not have acces • editing the same f We therefore id arrange that only critical section she should be as small The problem we , process is allowed 'i found one which 1 has some expectec Safety: The proto, any time. This safety prope excluded every pn useful. Therefore, • Liveness:Whenev, eventually Non-blocking:A i: Some rather crude '.>the processes, mai • ' might be natural] shared resource 111, property: ' No strict sequencil sequence. , following: 1]) ]). ving: in order to have oint along each path J now, in the current 'q,in each of the next AF in terms of AX ct, these equivalences in terms of AX: and 1t characterisation of I-checking algorithm tion 3.9). are equivalent? For :he pair which is not J ef,3](Hint: it might 10dels that have just he following equivaformulas to explain y often along every 3.4 Example: mutual excl11sion 4. Prove the Equivalences (3.1) and (3.2). * 5. Write pseudo-code for a recursive function TRANSLATE which takes as input an arbitrary CTL formula ef; and returns as output an equivalent CTL formula 1p whose only operators are among the set (..L,~,/\,AF, EU, EX}. 3.4 Example: mutual exclusion Let us now look at a larger example of verification using CTL, having to do with mutual exclusion. When concurrent processes share a resource (such as a file on a disk or a database entry). it may be necessary to ensure that they do not have access to it at the same time. Several processes simultaneously editing the same file would not be desirable. We therefore identify certain critical sections of each process' code and arrange that only one process can be in its critical section at a time. The critical section should include all the access to the shared resource (though it should be as small as possible so that no unnecessary exclusion takes place). The problem we are faced with is to find a protocol for determining which process is allowed to enter its critical section at which time. Once we have found one which we think works, we verify our solution by checking that it has some expected properties, such as the following ones: Safety: The protocol allows only one process to be in its critical section at any time. This safety property is not enough, since a protocol which permanently excluded every process from its critical section would be safe, but not very useful. Therefore, we should also require: Liveness: Whenever any process wants to enter its critical section, it will eventually be permitted to do so. Non-blocking: A process can always request to enter its critical section. Some rather crude protocols might work on the basis that they cycle through the processes, making each one in turn enter its critical section. Since it might be naturally the case that some of them request accesses to the shared resource more than others, we should make sure our protocol has the property: No strict sequencing: Processes need not enter their critical section in strict sequence. Ver(fication by model checking 3.4.1 Tilefi1·stmodelli11gattempt We will model two processes, each of which is in its non-critical state (n), or trying to enter its critical state (t), or in its critical state (c). Each individual process undergoes transitions in the cycle n -> t -+ c -+ n -+ ... , but the two processes interleave with each other. Consider the protocol given by the transition system ./It in Figure 3.121. The two processes start off in their non-critical sections (global state s0). State so is the only initial state, indicated by the incoming edge with no source. Either of them may now move to its trying state, but only one of them can ever make a transition at a time ( asynchronous interleaving). So there is a transition arrow from so to s1 and s5. From s1 (i.e. process 1 trying, process 2 non-critical) again two things can happen: either process 1 moves again (we go to s2), or process 2 moves (we go to s3). Notice that not every process can move in every state. For example, process 1 cannot move in state s7, since it cannot go into its critical section until process 2 comes out of its critical section. We cau verify the four properties by first describing them as CTL formulas: Safety: <J,1~ AG ,(CJ /\ c2). Clearly, AG ,(ci /\ c2) is satisfied in the initial state (indeed, in every state). Liveness: </>2~ AG (t1 -+ AF c1). This is not satisfied by the initial state, for we can find a state accessible from the initial state, namely s1, in 1 We write P1P2 ... Pmin a nodes to denote that p1,p2, ... , Pm are the only propositional atoms true at s. which t1 is path s1 -> s Non-blocking: <f,3~ (i.e.so, ss a1 No strict seqnencin: satisfied; e., for liveness, EXERCISES 3.5 "' 1. 0 bserve thai point of vie, that process good reason 2? The reason livern sion is that non-de1 over another. The I which of the proce, splitting s3 into twc The two states s3 ar first modelling atte trying states, but i1 whereas in s9 it is I labelling t1t2. The c 1hink of there beini initial labelling, wh: Remark3.9 The fc strict sequencing ar In this second n over-simplified, bee: on every tick of th may wish to mode: ticks, but if we inch {C}usion. a-critical state (n), or , (c). Each individual ---->n -> ... , but the ,e protocol given by rocesses start off in he only initial state, r of them may now ir make a transition sition arrow from so •n-critical)again two J to s2), or process 2 move in every state. it cannot go into its ection. :mas CTL formulas: itisfied in the initial by the initial state, ! state, namely s1, in ·opositional atoms ttue at s. 3.4 Example: 11wt11alexclusion which t1 is true but AF CJ is false, because there is a computation path s1 ---->s3 ---->s7 ---+ s1 -> ... on which c1 is always false. "Non-blocking:c{>3~ AG (111 ---->EX ti), which is satisfied, since every 111 state (i.e. so, ss and s6) has an (immediate) t1 successor. No strict sequencing: o/4~ EF(c 1/\ E[c1 U (~c1 /\ E[~c2 U ci])]). This is satisfied; e.g. by the mirror path to the computation path described for liveness, s5 --> s3 --> s4 -> s5 --+ .... Observe that the last three specifications have been written from the point of view of process 1. Can you modify those specifications such that process 2 also meets these constraints? Can you come up with a good reason explaining why we did not add the constraints of process 2? The reason liveness failed in our first attempt at modelling mutual exclusion is that non-determinism means it might continually favour one process over another. The problem is that the state s3 does not distinguish between which of the processes first went into its trying state. We can solve this by splitting s3 into two states. 3.4.2 The seco11d modelling attempt The two states s3 and s9 in Figure 3.13 both correspond to the state SJ in our first modelling attempt. They both record that both processes are in their trying states, but in SJ it is implicitly recorded that it is process 1 's turn, whereas in s9 it is process 2's turn. Note that states SJ and s9 both have the labelling 11 t2. The definition of CTL models does not preclude this. We can think of there being some other, hidden, variables which are not part of the initial labelling, which distinguish s3 and s9. Remark3.9 The four properties of safety, liveness, non-blocking and no strict sequencing are satisfied by the model in Figure 3. 13. In this second modelling attempt, our transition system is still slightly over-simplified, because we are assuming that it will move to a different state on every tick of the clock ( t)1ere are no transitions to the same state). We may wish to model that a process can stay in its critical state for several ticks, but if we include an arrow from s2, or s6, to itself, we will again violate Ver{fication by model checking representing t1t 2, namely s3 and 89. liveness. This problem will be solved later in this chapter when we consider 'fairness constraints' ( Section 3. 7). EXERCISES 3.6 1. Verify Remark 3.9. 3.5 A model-checking algol"ithm In general, interesting transition systems will have millions of states and the fornmla we are interested in checking may be quite long. It is therefore well worth trying to find an efficient algorithm. Our usage of the notion of a 'moder . // has included directed graphs and also their unwindings into infinite trees, given a designated initial state. On doing the exercises, you very probably realised that checks on the infinite tree are easier for you to do, since all possible paths are plainly visible. However, if we think of implementing a model checker on a computer, we certainly cannot unwind transition systems into an infinite tree. We need to do checks on finite data structures. This is the reason why we now have to develop new insights into the semantics of CTL. Such a deeper understanding will provide the basis for an efficient algorithm which, given .//, s E S and 4>. computes whether .ii, s I=rp holds. In the latter case, such an algorithm can be augmented to produce an actual path (=run) of the system demonstrating that . // cannot sa1 what causes that r There are vario1 as a computationa formula ¢ and a s1 ·yes· (j/, so I=¢ he inputs could be jm . model JI which s, If we solve the solution to the first the output set. Co1 for the first, we we . in turn, to decide algorithm to solve We present an algc • the set of states oi not need to be ab!, already seen that ti the propositional c adequate set of teir would simply pre-1 • output of TRANS . coded in Exercises •INPUT: a CTL 111 .First, change ¢ to • ; of the connectives >earlier in the chapt, Hhat are satisfied ti: outwards towards \ Suppose 1p is a : 'subformulas of 1P11 ¢ is any maximal-k : case analysis which 1ere are now two states'' ter when we consider ons of states and the ,g. It is therefore well I directed graphs and ,ated initial state. On ks on the infinite tree inly visible. However, mputer, we certainly Ne need to clo checks 10w have to develop :r nnclerstanding will en .//, s E S and ,j,, ,ch an algorithm can ystem demonstrating 3.5 A model-checking algorithm .that .// cannot satisfy ¢. That way, we may debug a system by trying to fix what causes that run to refute property ¢. There are various ways in which one could consider ? j/, soI=</> ;,as a computational problem. For example, one could have the model j/, the formula cf,and a state soas input; one would then expect a reply of the form :'yes' (.//, so I=cf,holds), or 'no' (.ll, so I=cf>does not hold). Alternatively, the ;inputs could be just .JI and ¢, where the output would be all states s of the 'model .II which satisfy ¢. If we solve the second of these two problems, we automatically have a solution to the first one, since we can simply check whether sois an element of the output set. Conversely, to solve the second problem, given an algorithm cfor the first, we would simply repeatedly call this algorithm with each state in turn, to decide whether it goes in the output set. We will describe an ,algorithm to solve the second problem. 3.5.1 Tile labellillg algoi·itlim 'We present an algorithm which, given a model and a CTL formula, outputs .the set of states of the model that satisfy the formula. The algorithm does ;not need to be able to handle every CTL connective explicitly, since we have already seen that the connectives _l, , and /I form an adequate set as far as ,:the propositional connectives are concerned; and AF, EU and EX form an '.· adequate set of temporal connectives. Given an arbitrary CTL formula <{,,we \would simply pre-process ¢, calling the model-checking algorithm with the ioutput of TRANSLATE (cfJ)as input, where TRANSLATE is the function •codec! in Exercises 3.4( 5), page 169. Here is the algorithm: INPUT: a CTL model JI!= (S,---+,L) and a CTL formula cf,. .OUTPUT: the set of states of .;It which satisfy ¢. 'iFirst, change¢ to the output of TRANSLATE(<{,), i.e. we write cf,in terms : of the connectives AF, EU, EX, /1, , and J_ using the equivalences given .earlier in the chapter. Next, label the states of .Ill with the subformulas of cf, that are satisfied there, starting with the smallest subformulas and working outwards towards ¢. Suppose 1p is a subformula of c/Jand states satisfying all the immediate subformulas of 1p have alrea<;ly been labelled. (An immediate subformula of </1is any maximal-length subformula other than ¢ itself.) We determine by a case analysis which states to label with 1p.If 1p is Repeat ... . . . until uo change. Fig.3.14. The iteration step of the procedure for labelling states with subformulas of the form AF1p1. J..: then no states are labelled with J... ® p: then labels with p if p E L(s). o 1p1/I 1/!2:label s with 1p1/I 1p2 ifs is already labelled both with v,1 and with 11'2· ® ~1p1: labels with ~1111ifs is not already labelled with 1/!l• o AF1f!1: -If any states is labelled with ,p1, label it with AF 1p1. -Repeat: label any state with AF 1/!l if all snccessor states are labelled with AF 1111,until there is no change. This step is illustrated in Figure . 3.14. e E[1p1U 1/!2]: -If any state s is labelled with 1p2, label it with E[v,1U v,2]. -Repeat: label any state with E[,p1 U 1p2]if it is labelled with 1/!1and least one of its successors is labelled with E[v.11 U 1p2], until there is no.: change. This step is illustrated in Figure 3.15. e EX ,p1: label any state with EX 1111 if one of its successors is labelled with 1/Jl. Having performed the labelling for all the subformulas of <jJ(including itself), we output the states which are labelled <j,. The complexity of this algorithm is O(f • V • (V + E)), where f is the. number of connectives in the formula, V is the number of states and E is the number of transitions; the algoritlun is linear in the size of the formula· and quadratic in the size of the model. • Fig. 3.15. The ite of the form E[1/!1 Instead of usin2 possible to write .probably be mo qifferent approa ,,to deal with EG t•EG1P1: -Label all ti -If any state -Repeat: de, is labelled , case for EU EG and wh: e can improv( ay of handlini )ye use EX, El t~ke care to sea :ates with subfonnulas ,th with V'1 and with l 1Pl· '!, r states are labelled illustrated in Figure U 1P2]. ,lied with 1p1 and at >2], until there is no ,ors is labelled with . of cf,(including ef, ,)), where f is the of states and E is size of the formula 3.5 A model-checking algorithm Repeat ... ~ 'PlE[,p1 U ,pz] 11'1 ~ ~ . . . until no change. iFig. 3.15. The iteration step of the procedure for labelling states with snbformulas '.of the form E[,p1 U 1p2]. Handling BG directly 'Instead of using a minimal adequate set of connectives, it would have been / possible to write similar routines for the other connectives. Indeed, this would '. probably be more efficient. The connectives AG and BG require a slightly different approach from that for the others, however. Here is the algorithm •• to deal with BG ,p1 directly: • EG1p1: -Label all the states with EG,p1. -If any states is not labelled with 'Pl, delete the label EG1p1. -Repeat: delete the label EGip1 from any state if none of its successors is labelled with BG 'Pl; until there is no change. Here, we label all the states with the subformula BG 1p1 and then whittle down this labelled set, instead of building it up from nothing as we did in the case for EU. Actually, there is no real difference betweeu this procedure for BG and what you would do if you translated it into ~AF~ as far as the final result is concerned. A variant which is more efficient We can improve the efficiency of our labelling algorithm by using a cleverer way of handling BG. Instead of using EX, EU and AF as the adequate set, we use EX, EU and BG instead. For EX and EU we do as before (but take care to search the model by backwards breadth-first searching, for this ensures that we won't have to pass over any node twice). For the EGv, case: Verification by model checking states satisfying 1p Fig. 3.16. A better way of handling EG. e restrict the graph to states satisfying 1/J,i.e. delete all other states and their transitions; find the maximal strongly connected components (SCCs); these are maximal regions of the state space in which every state is linked with ( = has a finite path to) every other one in that region. " use backwards breadth-first searching on the restlicted graph to find any state that can reach an SCC; see Figure 3.16. The complexity of this algorithm is O(f •(V + E)), i.e. linear both in the size of the model and in the size of the formula. Example3.10 We applied the basic algolithm to our second model of mutual exclusion with the formula E[,c 2 U c1]; see Figure 3.17. The algorithm labels all states which satisfy c1 during phase 1 with E[,c 2 U CJ].This labels s2 and s4. During phase 2, it labels all states which do not satisfy c2 and have a successor state that is already labelled. This labels states s1 and s3. During phase 3, we label so because it does not satisfy c2 and has a successor state (s1) which is already labelled. Thereafter, the algorithm terminates because no additional states get labelled: all unlabelled states either satisfy c2, or must pass through such a state to reach a labelled state. EXERCISES 3. 7 * 1. Apply the labelling algorithm to check the formulas ¢1, ¢2, ¢3 and q;4of the mutual exclusion model in Figure 3.12. 2. Apply the labelling algorithm to check the formulas ¢1, ¢2, ¢3 and • ¢4 of the mutual exclusion model in Figure 3.13. 3. Explain the construction of formula ¢4, used to express that the .. processes need not enter their critical section in strict sequence. Does,( it rely on the fact that the safety property ¢ 1 holds? 4. Inspecting the definition of the labelling algorithm, explain what . St 0: tin 2: E[,c2 S2_..,J..---J' 0: C1ll2 1: E[,c2 U ci] 0: c1t2 1: E[,c 2 Fig. 3.17. An example exclusion applied to ti happens if yo model). 3.5.2 The We present the pseu fin this chapter. Th( CCTL formula, i.e. a CThe program SAT e I.by means of the gr ·important preconditi< ;the program simply X(T I\ BF p3), since ,·tree according to the would make sure th '.SAT. However, we u ;'.preprocessing becaus :ig lj) }. other states and their '.s); these are maximal d with (= has a finite ed graph to find any inear both in the size ond model of mutual The algorithm labels U CJ]. This labels s2 ,t satisfy c2 and have tes s1 and s3. During has a successor state 1 terminates because either satisfy c2, or rnlas ¢1, ef,2, ef,3 and rnlas ef,1, ¢2, ef,3 and to express that the ;trict sequence. Does lds? rithm, explain what 3.5 A model-checking algorithm so 0: n1n2 3: E[,c 2 U ci] s1 S5 0: t1112 sS2__,.J---~.f'.. 0; c1n2 l: E[,c, Fig. 3.17. An example run of the labelling algorithm in our second model of mutual exclusion applied to the formula E[,c 2 U ct]. happens if you perform it on the formula p I\ ,p (in any state, in any model). 3.5.2 The pseudo-code of tlie model c!tecking algm·it!im We present the pseudo-code for the basic labelling alg01ithm given earlier . in this chapter. The main function SAT (for 'satisfies') takes as input a CTL formula, i.e. a formula over the Backus Naur fom1 in Definition 3.1. The program SAT expects a parse tree of some CTL fomrnla constructed by means of the grammar in Definition 3.1. This expectation reflects an important precondition on the correctness of the algorithm SAT. For example, the program simply would not know what to do with an input of the form X(T /\ EF p3), since this is not a CTL formula (it does not have a parse tree according to the grammar for CTL ). Hence, we also need a parser that would make sure that only .well-formed CTL formulas are being fed into SAT. However, we merely focus on the development of SAT without such preprocessing because this is the prime objective of this section. Verification by model checking The pseudo-code we write for SAT looks a bit like fragments of FORTRAN or Pascal code; we use functions with a keyword returnthat indicates which result the function should return. We will also use natural language to indicate the case analysis over the root node of the parse tree of <f,.The declaration local var declares some fresh variables local to the current instance of the procedure in question, whereas repeat until executes the command which follows it repeatedly, until the condition becomes true. Additionally, we employ suggestive notation for the operations on sets, like intersection, set complement and so forth. In reality we wonld need an abstract data type, called SETS, together with implementations of these operations, but for now we are interested only in the mechanism in principle of the algorithm for SAT; any (correct and efficient) implementation of sets would do and we study snch an implementation in Chapter 6. We assume that SAT has access to all the relevant parts of the model: S, --+ and L. In particular, we ignore the fact that SAT would require a description of ..$! as input as well. We simply assume that SAT operates directly on any such given model. Note how SAT implicitly translates ¢ into an equivalent formula of the adequate set chosen. The algorithm is presented in Figure 3.18 and its subfunctions in Figures 3.19-3.21. They use program variables X, Y, V and W of type SETS. The program for SAT simply handles the easy cases directly and passes more complicated cases on to special procedures, which in turn might call SAT recursivelyon subexpressions. Of course, we still need to make sure that this algorithm is correct. This will be handled in Section 3.9. 3.5.3 The 'state explosion' p1·ohlem Although the labelling algorithm (with the clever way of handling EG) is. linear in the size of the model, unfortunately the size of the model is itself exponential in the number of variables and the number of components of the system which execute in parallel. This means that, for example, adding a·,. boolean variable to your program will double the complexity of verifying a property of it. The tendency of the state space to become very large is known as the . state explosion problem. A lot of research has gone into finding ways of/ overcoming it, including the use of: " Efficient data structures, called ordered binary decision diagrams (OBDDs),, functionSAT ( ¢)/* determines the se begin case </>is T : retun ¢ is J_ : returi ¢ is atomic: r, ¢ is •¢1 : ret, ¢ is ¢1 /\ ¢2 : ,pis ¢1 V ¢2 : ¢ is ¢1 -► ¢2 ¢ is AX,f,1 : r ¢ is EX,t,1 : r, </>is A[¢1 U <j ¢ is E[¢1 U ¢ ¢ is EF </>1: n ¢ is EG¢ 1 : r, ¢ is AF ¢1 : r< ¢ is AG¢1 : r end case \end function '' Fig. 3.18. The functic . 9f states satisfying th i respectively, if EX, E iffunctionSATEx ( ¢)•/* determines the set 'local var X, Y '.begin X := SAT(¢); Y := {so ES Iso returnY end which represent s, •>in Chapter 6 in d, • Abstraction: we ,.> relevant to the fo1 ; Partial order redu, \• component traces be checked is c, model-checkin 3.5 A model-checking algorithm e fragments of FOR-. ·dreturnthat indicates se natural language to rse tree of¢. The deco the current instance • rncutes the command 1es true. Additionally, sets, like intersection, an abstract data type, Jerations, but for now of the algorithm for ets would do and we e that SAT has access particular, we ignore as input as well. We :h given model. Note mula of the adeqnate subfunctions in Fignd W of type SETS. ectly and passes more turn might call SAT rithm is correct. This 1 of handling BG) is of the model is itself er of components of orexample, adding a plexity of verifying a rge is known as the into finding ways of 1 diagrams (OBDDs), ;.functionSAT(</>)/* detem1ines the set of states satisfying ¢ * / · begin case ,J,is T : returnS q, is ..L : return0 ¢ is atomic: return{s ES I¢ E L(s)) ¢ is •¢1 : returnS -SAT(</>1) q,is ¢1 /\ ¢2 : returnSAT(q,1) n SAT(q,2) </>is</>,V </>2 : returnSAT(</>1)U SAT(</>2) ¢ is ¢1 -> ¢2 : returnSAT ( ,¢ V ¢2) q,is AX </>1: returnSAT ( ,EX ,q,i) ¢ is EX ¢1 : returnSAT Ex( ¢I) ¢ is A[</>1 U </>2]: returnSAT( ,(E[ ,¢ 2U ( ·¢1 /\ ,q12)]VEG ·¢2)) ¢ is E[</>1 U </>2] ¢2): returnSATEU(</>1, ¢ is EF¢ 1 : returnSAT(E(T U ¢1)) ¢ is EG¢ 1 : returnSAT(,AF,¢ 1) <fais AF ¢1 : returnSATAF (</>1) </>is AG ¢1 : returnSAT ( ,EF ,q,J) end case end function Fig. 3.18. The function SAT. It takes a CTL formula as input and returns the set of states satisfying the formula. It calls the functions SATEx, SAT EU and SATAF, respectively, if EX, EU or AF is the root of the input's parse tree. functionSAT EX ( ¢) /* determines the set of states satisfying EX¢ */local var X, Y begin X :=SAT(¢); Y := {soE S Iso-> s1for some s1 E X}; returnY end Fig. 3.19. The function SATEx-It computes the states satisfying¢ by calling SAT. Then, it looks backwards along -> to find the states satisfying EX¢. which represent sets of states instead of individual states. We study these in Chapter 6 in detail. • Abstraction: we abstract away variables in the model which are not relevant to the formula being checked. o Partial order reduction: for asynchronous systems, several interleavings of component traces may be equivalent as far as satisfaction of the formnla to be checked is concerned. This can often substantially reduce the size of the model-checking problem. Verification by model checking function SAT AF ( <p) /"' determines the set of states satisfying AP <f,* / local var X, Y begin X:=S; Y := SAT(¢); repeat until X = Y begin X:=Y; Y :=YU {s Ifor alls' withs---->s' we haves' E Y} end return Y end Pig. 3.20. The function SATAF· It computes the states satisfying <f,by calling SAT. Then, it accumulates states satisfying AP <f,in the manner described in the labelling algorithm. functionSAT EU ( <f,,VJ)/* determines the set of states satisfying E[<f, U 1p] * / local var W, X, Y begin W :=SAT(<f,); X :=S; Y := SAT(1p); repeat until X = Y begin X:=Y; Y := YU (W n {sIexistss' such thats---+ s' ands' E Y} end returnY end Pig. 3.21. The function SATEu• It computes the states satisfying <f,by calling SAT. Then, it accumulates states satisfying E[<f, U 1p]in the manner described in the labelling algorithm. 0 Induction: model-checking systems with (e.g.) large numbers of identical, or similar, components can often be implemented by 'induction' on this number. 0 Composition: break the verification problem down into several simpler verification problems. The last four issues are beyond the scope of this book, but references may be found at the ends of Chapters 3 and 6. EXERCISES 3.8 ' * 1. For mutual processes to that <p4is fa 2. Extend the subformulas [Question: v like that for * 3. Write the p of deleting 1 .So far, this chapte one continue in thj checking is that it ' implementations w /tion, we look at th, '') SMV ('symbolic m : models we have be, of CTL formulas a SMV is freely dii . can be found at th SMV, but provid reader should read SMV takes as ii • and some specific, • • word 'true' if the , ing why the spe, program. SMV programs ming language C, Modules can dec!: 'give the initial , \sion in terms of t Z:.non-detenninistic I ;ment at all). Non\ abstraction. ¢ by callingSAT. ed in the labelling ¢ by callingSAT. r described in the bers of identical.> 1duction' on this •• ; ) several simpler ' 1t references may 1813.6 11,e SMV system * 1. For nrntnal exclusion, draw a transition system which forces the two processes to enter their critical section in strict sequence and show that <f,4 is false of its initial state. 2. Extend the pseudo-code of Section 3.5.2 so that it can deal with subformnlas AG 1/'1,without rewriting it in terms of other formulas. [Question: will your routine be more like the routine for AF, or more like that for EG on page 175? Why?] * 3. Write the pseudo-code for SAT EG, based on the description in terms of deleting labels given in Section 3.5.1. 3.6 The SMV system So far, this chapter has been quite theoretical; and the sections after this one continue in this vein. However, one of the exciting things about model checking is that it is also a practical subject, for there are several efficient implementations which can check large systems in realistic time. In this section, we look at the best-known of the CTL model checkers, which is called SMV ('symbolic model verifier'). It provides a language for describing the models we have been drawing as diagrams and it directly checks the validity • of CTL formulas on those models. SMV is freely distributed and can be found on the internet. Further details can be found at the end of this chapter. We do not give a full introduction to SMV, but provide just enough information to give the flavour. The serious reader should read more about SMV in the references. SMV takes as input a text consisting of a program describing a model and some specifications (CTL formulas). It produces as output either the word 'true' if the specifications hold for all initial states, or a trace showing why the specification is false for the model determined by our program. SMV programs consist of one or more modules. As in the programming language C, or Java, one of the modules must be called main. Modules can declare variables and assign to them. Assignments usually give the initial value of a variable and its next value as an expression in terms of the current values of variables. This expression can be non-deterministic ( denoted by several expressions in braces, or no assignment at all). Non-determinism is· used to model the environment and for abstraction. 