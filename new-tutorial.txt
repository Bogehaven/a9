A Tutorial on Uppaal 4.0 Updated November 28, 2006 Gerd Behrmann, Alexandre David, and Kim G. Larsen Department of Computer Science, Aalborg University, Denmark {behrmann,adavid,kgl}@cs.auc.dk. Abstract. This is a tutorial paper on the tool Uppaal. Its goal is to be a short introduction on the ﬂavour of timed automata implemented in the tool, to present its interface, and to explain how to use the tool. The contribution of the paper is to provide reference examples and modelling patterns. 1 Introduction Uppaal is a toolbox for veriﬁcation of real-time systems jointly developed by Uppsala University and Aalborg University. It has been applied successfully in case studies ranging from communication protocols to multimedia applications [35,55,24,23,34,43,54,44,30]. The tool is designed to verify systems that can be modelled as networks of timed automata extended with integer variables, structured data types, user deﬁned functions, and channel synchronisation. The ﬁrst version of Uppaal was released in 1995 [52]. Since then it has been in constant development [21,5,13,10,26,27]. Experiments and improvements include data structures [53], partial order reduction [20], a distributed version of Uppaal [17,9], guided and minimal cost reachability [15,51,16], work on UML Statecharts [29], acceleration techniques [38], and new data structures and memory reductions [18,14]. Version 4.0 [12] brings symmetry reduction [36], the generalised sweep-line method [49], new abstraction techniques [11], priorities [28], and user deﬁned functions to the mainstream. Uppaal has also generated related Ph.D. theses [50,57,45,56,19,25,32,8,31]. It features a Java user interface and a veriﬁcation engine written in C++ . It is freely available at http://www.uppaal.com/. This tutorial covers networks of timed automata and the ﬂavour of timed automata used in Uppaal in section 2. The tool itself is described in section 3, and three extensive examples are covered in sections 4, 5, and 6. Finally, section 7 introduces common modelling patterns often used with Uppaal. 2 Timed Automata in Uppaal The model-checker Uppaal is based on the theory of timed automata [4] (see [42] for automata theory) and its modelling language o ers additional features such as bounded integer variables and urgency. The query language of Uppaal, used to specify properties to be checked, is a subset of TCTL (timed computation tree logic) [39,3]. In this section we present the modelling and the query languages of Uppaal and we give an intuitive explanation of time in timed automata. 2.1 The Modelling Language Networks of Timed Automata A timed automaton is a ﬁnite-state machine extended with clock variables. It uses a dense-time model where a clock variable evaluates to a real number. All the clocks progress synchronously. In Uppaal, a system is modelled as a network of several such timed automata in parallel. The model is further extended with bounded discrete variables that are part of the state. These variables are used as in programming languages: They are read, written, and are subject to common arithmetic operations. A state of the system is deﬁned by the locations of all automata, the clock values, and the values of the discrete variables. Every automaton may ﬁre an edge (sometimes misleadingly called a transition) separately or synchronise with another automaton1 , which leads to a new state. Figure 1(a) shows a timed automaton modelling a simple lamp. The lamp has three locations: off, low, and bright. If the user presses a button, i.e., synchronises with press?, then the lamp is turned on. If the user presses the button again, the lamp is turned o . However, if the user is fast and rapidly presses the button twice, the lamp is turned on and becomes bright. The user model is shown in Fig. 1(b). The user can press the button randomly at any time or even not press the button at all. The clock y of the lamp is used to detect if the user was fast (y< 5) or slow (y>= 5). press? press?y>=5 press? press? off y:=0 low brighty<5 idle press! ‚‚‚‚‚ (a) Lamp. (b) User. Fig. 1. The simple lamp example. We give the basic deﬁnitions of the syntax and semantics for the basic timed automata. In the following we will skip the richer ﬂavour of timed automata supported in Uppaal, i.e., with integer variables and the extensions of urgent and committed locations. For additional information, please refer to the help 1 or several automata in case of broadcast synchronisation, another extension of timed automata in Uppaal. menu inside the tool. We use the following notations: C is a set of clocks and B(C) is the set of conjunctions over simple conditions of the form x ⊲⊳ c or x − y ⊲⊳ c, where x, y ∈ C, c ∈ N and ⊲⊳∈{<, ≤, =, ≥,>}. A timed automaton is a ﬁnite directed graph annotated with conditions over and resets of non-negative real valued clocks. Deﬁnition 1 (Timed Automaton (TA)). A timed automaton is a tuple (L, l0 , C, A, E, I), where L is a set of locations, l0 ∈ L is the initial location, C is the set of clocks, A is a set of actions, co-actions and the internal τ -action, E ⊆ L × A × B(C) × 2C × L is a set of edges between locations with an action, a guard and a set of clocks to be reset, and I : L → B(C) assigns invariants to locations. &#3; In the previous example on Fig. 1, y:=0 is the reset of the clock y, and the labels press? and press! denote action–co-action (channel synchronisations here). We now deﬁne the semantics of a timed automaton. A clock valuation is a function u : C → R≥0 from the set of clocks to the non-negative reals. Let RC be the set of all clock valuations. Let u0 (x)=0 for all x ∈ C. We will abuse the notation by considering guards and invariants as sets of clock valuations, writing u ∈ I(l) to mean that u satisﬁes I(l). AB action transition AB x<3 <B,x=1> &#1;&#1;&#1;&#1;&#1;&#1;&#1;delay(+1) transition&#1;&#1;&#1;&#1;&#1;&#1;&#1; x<3 action A BA Bstate: <A,x=1> transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;OK&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; x<3 x<3 &#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; <A,x=2> <A,x=3>&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; invalid &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; delay(+2) transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; AB&#1;&#1;&#1;&#1;&#1;&#1;&#1; action &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;transition &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;x<3 &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1;&#1; &#1;&#1;&#1;&#1;&#1;&#1;&#1; <A,x=3> <A,x=3> invalid state: invariant x<3 violated Fig. 2. Semantics of TA: di erent transitions from a given initial state. Deﬁnition 2 (Semantics of TA). Let (L, l0 , C, A, E, I) be a timed automaton. The semantics is deﬁned as a labelled transition system S, s0 , →, where S ⊆ L× RC is the set of states, s0 =(l0 ,u0 ) is the initial state, and →⊆ S ×(R≥0 ∪A)×S is the transition relation such that: d :0 ≤ d ′ u + d ′ – (l, u) −→ (l, u + d) if ∀d ′ ≤ d =⇒∈ I(l), and a – (l, u) −→ (l ′ ,u ′ ) if there exists e =(l, a, g, r, l ′ ) ∈ E s.t. u ∈ g, ′′ u =[r → 0]u, and u ∈ I(l ′ ), 3 where for d ∈ R≥0 , u + d maps each clock x in C to the value u(x)+ d, and [r → 0]u denotes the clock valuation which maps each clock in r to 0 and agrees with u over C \ r. &#3; Figure 2 illustrates the semantics of TA. From a given initial state, we can choose to take an action or a delay transition (di erent values here). Depending of the chosen delay, further actions may be forbidden. Timed automata are often composed into a network of timed automata over a common set of clocks and actions, consisting of n timed automata Ai = (Li,l0 , C, A, Ei,Ii), 1 ≤ i ≤ n. A location vector is a vector ¯l =(l1 ,...,ln).i We compose the invariant functions into a common function over location vectors I(¯l)= ∧iIi(li). We write ¯l[l ′ /li] to denote the vector where the ith elementi li of ¯l is replaced by li ′ . In the following we deﬁne the semantics of a network of timed automata. Deﬁnition 3 (Semantics of a network of Timed Automata). Let Ai = (Li,l0 , C, A, Ei,Ii) be a network of n timed automata. Let ¯l0 =(l10 ,...,l0 ) be thein initial location vector. The semantics is deﬁned as a transition system S, s0 , →, where S =(L1 × · × Ln) × RC is the set of states, s0 = (¯l0 ,u0 ) is the initial state, and →⊆ S × S is the transition relation deﬁned by: d – (¯l, u) −→ (¯l, u + d) if ∀d ′ :0 ≤ d ′ ≤ d =⇒ u + d ′ ∈ I(¯l). a ˝gr – (¯l, u) −→ (¯l[l ′ /li],u ′ ) if there exists li −−→ li ′ s.t. u ∈ g,i ′′ u =[r → 0]u and u ∈ I(¯l[l ′ /li]).i ac?gi ri – (¯l, u) −→ (¯l[l ′ /lj,l ′ /li],u ′ ) if there exist li −−−→ l ′ andji i c!gj rj ′′ lj −−−→ lj ′ s.t. u ∈ (gi ∧ gj ), u =[ri ∪ rj → 0]u and u ∈ I(¯l[lj ′ /lj,li ′ /li]). &#3; As an example of the semantics, the lamp in Fig. 1 may have the following states (we skip the user): (Lamp.off,y = 0) → (Lamp.off,y = 3) → (Lamp.low,y = 0) → (Lamp.low,y =0.5) → (Lamp.bright,y =0.5) → (Lamp.bright,y =1000) ... Timed Automata in Uppaal The Uppaal modelling language extends timed automata with the following additional features (see Fig. 3: Templates automata are deﬁned with a set of parameters that can be of any type (e.g., int, chan). These parameters are substituted for a given argument in the process declaration. Constants are declared as const name value. Constants by deﬁnition cannot be modiﬁed and must have an integer value. Bounded integer variables are declared as int[min,max] name, where min and max are the lower and upper bound, respectively. Guards, invariants, and assignments may contain expressions ranging over bounded integer variables. The bounds are checked upon veriﬁcation and violating a bound leads to an invalid state that is discarded (at run-time). If the bounds are omitted, the default range of -32768 to 32768 is used. Fig. 3. Declarations of a constant and a variable, and illustration of some of the channel synchronisations between two templates of the train gate example of Section 4, and some committed locations. Binary synchronisation channels are declared as chan c. An edge labelled with c! synchronises with another labelled c?. A synchronisation pair is chosen non-deterministically if several combinations are enabled. Broadcast channels are declared as broadcast chan c. In a broadcast synchronisation one sender c! can synchronise with an arbitrary number of receivers c?. Any receiver than can synchronise in the current state must do so. If there are no receivers, then the sender can still execute the c! action, i.e. broadcast sending is never blocking. Urgent synchronisation channels are declared by preﬁxing the channel declaration with the keyword urgent. Delays must not occur if a synchronisation transition on an urgent channel is enabled. Edges using urgent channels for synchronisation cannot have time constraints, i.e., no clock guards. Urgent locations are semantically equivalent to adding an extra clock x, that is reset on all incoming edges, and having an invariant x<=0 on the location. Hence, time is not allowed to pass when the system is in an urgent location. Committed locations are even more restrictive on the execution than urgent locations. A state is committed if any of the locations in the state is committed. A committed state cannot delay and the next transition must involve an outgoing edge of at least one of the committed locations. Arrays are allowed for clocks, channels, constants and integer variables. They are deﬁned by appending a size to the variable name, e.g. chan c[4]; clock a[2]; int[3,5] u[7];. Initialisers are used to initialise integer variables and arrays of integer variables. For instance, int i = 2; or int i[3] = {1, 2, 3};. Record types are declared with the struct construct like in C. Custom types are deﬁned with the C-like typedef construct. You can deﬁne any custom-type from other basic types such as records. User functions are deﬁned either globally or locally to templates. Template parameters are accessible from local functions. The syntax is similar to C except that there is no pointer. C++ syntax for references is supported for the arguments only. Expressions in Uppaal Expressions in Uppaal range over clocks and integer variables. The BNF is given in Fig. 33 in the appendix. Expressions are used with the following labels: Select A select label contains a comma separated list of name : type expressions where name is a variable name and type is a deﬁned type (built-in or custom). These variables are accessible on the associated edge only and they will take a non-deterministic value in the range of their respective types. Guard A guard is a particular expression satisfying the following conditions: it is side-e ect free; it evaluates to a boolean; only clocks, integer variables, and constants are referenced (or arrays of these types); clocks and clock di erences are only compared to integer expressions; guards over clocks are essentially conjunctions (disjunctions are allowed over integer conditions). A guard may call a side-e ect free function that returns a bool, although clock constraints are not supported in such functions. Synchronisation A synchronisation label is either on the form Expression! or Expression? or is an empty label. The expression must be side-e ect free, evaluate to a channel, and only refer to integers, constants and channels. Update An update label is a comma separated list of expressions with a side-e ect; expressions must only refer to clocks, integer variables, and constants and only assign integer values to clocks. They may also call functions. Invariant An invariant is an expression that satisﬁes the following conditions: it is side-e ect free; only clock, integer variables, and constants are referenced; it is a conjunction of conditions of the form x<e or x<=e where x is a clock reference and e evaluates to an integer. An invariant may call a side-e ect free function that returns a bool, although clock constraints are not supported in such functions. 2.2 The Query Language The main purpose of a model-checker is verify the model w.r.t. a requirement speciﬁcation. Like the model, the requirement speciﬁcation must be expressed in a formally well-deﬁned and machine readable language. Several such logics exist in the scientiﬁc literature, and Uppaal uses a simpliﬁed version of TCTL. Like in TCTL, the query language consists of path formulae and state formulae.2 State formulae describe individual states, whereas path formulae quantify over paths or traces of the model. Path formulae can be classiﬁed into reachability, safety and liveness. Figure 4 illustrates the di erent path formulae supported by Uppaal. Each type is described below. State Formulae A state formula is an expression (see Fig. 33) that can be evaluated for a state without looking at the behaviour of the model. For instance, this could be a simple expression, like i == 7, that is true in a state whenever i equals 7. The syntax of state formulae is a superset of that of guards, i.e., a state formula is a side-e ect free expression, but in contrast to guards, the use of disjunctions is not restricted. It is also possible to test whether a particular process is in a given location using an expression on the form P.l, where P is a process and l is a location. In Uppaal, deadlock is expressed using a special state formula (although this is not strictly a state formula). The formula simply consists of the keyword deadlock and is satisﬁed for all deadlock states. A state is a deadlock state if there are no outgoing action transitions neither from the state itself or any of its delay successors. Due to current limitations in Uppaal, the deadlock state formula can only be used with reachability and invariantly path formulae (see below). Reachability Properties Reachability properties are the simplest form of properties. They ask whether a given state formula, ϕ, possibly can be satisﬁed 2 In contrast to TCTL, Uppaal does not allow nesting of path formulae. Fig. 4. Path formulae supported in Uppaal. The ﬁlled states are those for which a given state formulae ° holds. Bold edges are used to show the paths the formulae evaluate on. by any reachable state. Another way of stating this is: Does there exist a path starting at the initial state, such that ϕ is eventually satisﬁed along that path. Reachability properties are often used while designing a model to perform sanity checks. For instance, when creating a model of a communication protocol involving a sender and a receiver, it makes sense to ask whether it is possible for the sender to send a message at all or whether a message can possibly be received. These properties do not by themselves guarantee the correctness of the protocol (i.e. that any message is eventually delivered), but they validate the basic behaviour of the model. We express that some state satisfying ϕ should be reachable using the path formula E3 ϕ. In Uppaal, we write this property using the syntax E<> ϕ. Safety Properties Safety properties are on the form: “something bad will never happen”. For instance, in a model of a nuclear power plant, a safety property might be, that the operating temperature is always (invariantly) under a certain threshold, or that a meltdown never occurs. A variation of this property is that “something will possibly never happen”. For instance when playing a game, a safe state is one in which we can still win the game, hence we will possibly not loose. In Uppaal these properties are formulated positively, e.g., something good is invariantly true. Let ϕ be a state formulae. We express that ϕ should be true 3in all reachable states with the path formulae A&#3;ϕ, whereas E&#3;ϕ says that 3 Notice that A&#3;'= ¬E3 ¬' there should exist a maximal path such that ϕ is always true.4 In Uppaal we write A[] ϕ and E[] ϕ, respectively. Liveness Properties Liveness properties are of the form: something will eventually happen, e.g. when pressing the on button of the remote control of the television, then eventually the television should turn on. Or in a model of a communication protocol, any message that has been sent should eventually be received. In its simple form, liveness is expressed with the path formula A3 ϕ, meaning ϕ is eventually satisﬁed.5 The more useful form is the leads to or response property, written ϕψ which is read as whenever ϕ is satisﬁed, then eventually ψ will be satisﬁed, e.g. whenever a message is sent, then eventually it will be received.6 In Uppaal these properties are written as A<> ϕ and ϕ --> ψ, respectively. 2.3 Understanding Time Invariants and Guards Uppaal uses a continuous time model. We illustrate the concept of time with a simple example that makes use of an observer. Normally an observer is an add-on automaton in charge of detecting events without changing the observed system. In our case the clock reset (x:=0) is delegated to the observer for illustration purposes. Figure 5 shows the ﬁrst model with its observer. We have two automata in parallel. The ﬁrst automaton has a self-loop guarded by x>=2, x being a clock, that synchronises on the channel reset with the second automaton. The second automaton, the observer, detects when the self loop edge is taken with the location taken and then has an edge going back to idle that resets the clock x. We moved the reset of x from the self loop to the observer only to test what happens on the transition before the reset. Notice that the location taken is committed (marked c) to avoid delay in that location. The following properties can be veriﬁed in Uppaal (see section 3 for an overview of the interface). Assuming we name the observer automaton Obs, we have: – A[] Obs.taken imply x>=2 : all resets o x will happen when x is above 2. This query means that for all reachable states, being in the location Obs.taken implies that x>=2. – E<> Obs.idle and x>3 : this property requires, that it is possible to reachable state where Obs is in the location idle and x is bigger than 3. Essentially we check that we may delay at least 3 time units between resets. The result would have been the same for larger values like 30000, since there are no invariants in this model. 4 A maximal path is a path that is either inﬁnite or where the last state has no outgoing transitions. 5 Notice that A3 '= ¬E&#3;¬'. 6 Experts in TCTL will recognise that ' is equivalent to A&#3;(' =) A3 ) 4 reset? 2idle takenloop x>=2 reset! x:=0 2 4 6 8 "time" (a) Test. (b) Observer. (c) Behaviour: one possible run. Fig. 5. First example with an observer. ‚‚‚‚‚ 2 4 6 8 "time" (a) Test. (b) Updated behaviour with an invariant. Fig. 6. Updated example with an invariant. The observer is the same as in Fig. 5 and is not shown here. We update the ﬁrst model and add an invariant to the location loop, as shown in Fig. 6. The invariant is a progress condition: the system is not allowed to stay in the state more than 3 time units, so that the transition has to be taken and the clock reset in our example. Now the clock x has 3 as an upper bound. The following properties hold: – A[] Obs.taken imply (x>=2 and x<=3) shows that the transition is taken when x is between 2 and 3, i.e., after a delay between 2 and 3. – E<> Obs.idle and x>2 : it is possible to take the transition when x is between 2 and 3. The upper bound 3 is checked with the next property. – A[] Obs.idle imply x<=3 : to show that the upper bound is respected. The former property E<> Obs.idle and x>3 no longer holds. Now, if we remove the invariant and change the guard to x>=2 and x<=3, you may think that it is the same as before, but it is not! The system has no progress condition, just a new condition on the guard. Figure 7 shows what happens: the system may take the same transitions as before, but deadlock may also occur. The system may be stuck if it does not take the transition after 3 time units. In fact, the system fails the property A[] not deadlock. The property A[] Obs.idle imply x<=3 does not hold any longer and the deadlock can also be illustrated by the property A[] x>3 imply not Obs.taken, i.e., after 3 time units, the transition is not taken any more. 4 loop 2x>=2 && x<=3 reset! 2 4 6 8 "time" (a) Test. (b) Updated behaviour with a guard and no invariant. Fig. 7. Updated example with a guard and no invariant. S0 S1 S2 S0 S1 S2 Fig. 8. Automata in parallel with normal, urgent and commit states. The clocks are local, i.e., P0.x and P1.x are two di erent clocks. Committed and Urgent Locations There are three di erent types of locations in Uppaal: normal locations with or without invariants (e.g., x<=3 in the previous example), urgent locations, and committed locations. Figure 8 shows 3 automata to illustrate the di erence. The location marked u is urgent and the one marked c is committed. The clocks are local to the automata, i.e., x in P0 is di erent from x in P1. To understand the di erence between normal locations and urgent locations, we can observe that the following properties hold: – E<> P0.S1 and P0.x>0 : it is possible to wait in S1 of P0. – A[] P1.S1 imply P1.x==0 : it is not possible to wait in S1 of P1. An urgent location is equivalent to a location with incoming edges reseting a designated clock y and labelled with the invariant y<=0. Time may not progress in an urgent state, but interleavings with normal states are allowed. A committed location is more restrictive: in all the states where P2.S1 is active (in our example), the only possible transition is the one that ﬁres the edge outgoing from P2.S1.A state having a committed location active is said to be committed: delay is not allowed and the committed location must be left in the successor state (or one of the committed locations if there are several ones). 3 Overview of the Uppaal Toolkit Uppaal uses a client-server architecture, splitting the tool into a graphical user interface and a model checking engine. The user interface, or client, is implemented in Java and the engine, or server, is compiled for di erent platforms (Linux, Windows, Solaris).7 As the names suggest, these two components may be run on di erent machines as they communicate with each other via TCP/IP. There is also a stand-alone version of the engine that can be used on the command line. 3.1 The Java Client The idea behind the tool is to model a system with timed automata using a graphical editor, simulate it to validate that it behaves as intended, and ﬁnally to verify that it is correct with respect to a set of properties. The graphical interface (GUI) of the Java client reﬂects this idea and is divided into three main parts: the editor, the simulator, and the veriﬁer, accessible via three “tabs”. The Editor A system is deﬁned as a network of timed automata, called processes in the tool, put in parallel. A process is instantiated from a parameterised template. The editor is divided into two parts: a tree pane to access the di erent templates and declarations and a drawing canvas/text editor. Figure 9 shows the editor with the train gate example of section 4. Locations are labelled with names and invariants and edges are labelled with guard conditions (e.g., e==id), synchronisations (e.g., go?), and assignments (e.g., x:=0). The tree on the left hand side gives access to di erent parts of the system description: Global declaration Contains global integer variables, clocks, synchronisation channels, and constants. Templates Train, Gate, and IntQueue are di erent parameterised timed automata. A template may have local declarations of variables, channels, and constants. Process assignments Templates are instantiated into processes. The process assignment section contains declarations for these instances. System deﬁnition The list of processes in the system. The syntax used in the labels and the declarations is described in the help system of the tool. The local and global declarations are shown in Fig. 10. The graphical syntax is directly inspired from the description of timed automata in section 2. Fig. 9. The train automaton of the train gate example. The select button is activated in the tool-bar. In this mode the user can move locations and edges or edit labels. The other modes are for adding locations, edges, and vertices on edges (called nails). A new location has no name by default. Two text ﬁelds allow the user to deﬁne the template name and its parameters. Useful trick: The middle mouse button is a shortcut for adding new elements, i.e. pressing it on the canvas, a location, or edge adds a new location, edge, or nail, respectively. The Simulator The simulator can be used in three ways: the user can run the system manually and choose which transitions to take, the random mode can be toggled to let the system run on its own, or the user can go through a trace (saved or imported from the veriﬁer) to see how certain states are reachable. Figure 11 shows the simulator. It is divided into four parts: The control part is used to choose and ﬁre enabled transitions, go through a trace, and toggle the random simulation. The variable view shows the values of the integer variables and the clock constraints. Uppaal does not show concrete states with actual values for the clocks. Since there are inﬁnitely many of such states, Uppaal instead shows sets of concrete states known as symbolic states. All concrete states in a symbolic state share the same location vector and the same values for discrete variables. The possible values of the clocks is described by a set of con7 A version for Mac OS X is in preparation. straints. The clock validation in the symbolic state are exactly those that satisfy all constraints. The system view shows all instantiated automata and active locations of the current state. The message sequence chart shows the synchronisations between the di erent processes as well as the active locations at every step. The Veriﬁer The veriﬁer “tab” is shown in Fig. 12. Properties are selectable in the Overview list. The user may model-check one or several properties,8 insert or remove properties, and toggle the view to see the properties or the comments in the list. When a property is selected, it is possible to edit its deﬁnition (e.g., E<> Train1.Cross and Train2.Stop . . . ) or comments to document what the property means informally. The Status panel at the bottom shows the communication with the server. When trace generation is enabled and the model-checker ﬁnds a trace, the user is asked if she wants to import it into the simulator. Satisﬁed properties are marked green and violated ones red. In case either an over approximation or an under approximation has been selected in the options menu, then it may happen that the veriﬁcation is inconclusive with the approximation used. In that case the properties are marked yellow. 8 several properties only if no trace is to be generated. Fig. 11. View of the simulator tab for the train gate example. The interpretation of the constraint system in the variable panel depends on whether a transition in the transition panel is selected or not. If no transition is selected, then the constrain system shows all possible clock valuations that can be reached along the path. If a transition is selected, then only those clock valuations from which the transition can be taken are shown. Keyboard bindings for navigating the simulator without the mouse can be found in the integrated help system. 3.2 The Stand-alone Veriﬁer When running large veriﬁcation tasks, it is often cumbersome to execute these from inside the GUI. For such situations, the stand-alone command line veriﬁer called verifyta is more appropriate. It also makes it easy to run the veriﬁcation on a remote UNIX machine with memory to spare. It accepts command line arguments for all options available in the GUI, see Table 3 in the appendix. 4 Example 1: The Train Gate 4.1 Description The train gate example is distributed with Uppaal. It is a railway control system which controls access to a bridge for several trains. The bridge is a critical shared resource that may be accessed only by one train at a time. The system is deﬁned as a number of trains (assume 4 for this example) and a controller. A train can not be stopped instantly and restarting also takes time. Therefor, there are timing constraints on the trains before entering the bridge. When approaching, a train sends a appr! signal. Thereafter, it has 10 time units to receive a stop signal. This allows it to stop safely before the bridge. After these 10 time units, it takes further 10 time units to reach the bridge if the train is not stopped. If a train is stopped, it resumes its course when the controller sends a go! signal to it after a previous train has left the bridge and sent a leave! signal. Figures 13 and 14 show two situations. 4.2 Modelling in Uppaal The model of the train gate has three templates: Train is the model of a train, shown in Fig. 9. Gate is the model of the gate controller, shown in Fig. 15. IntQueue is the model of the queue of the controller, shown in Fig. 16. It is simpler to separate the queue from the controller, which makes it easier to get the model right. The Template of the Train The template in Fig. 9 has ﬁve locations: Safe, Appr, Stop, Start, and Cross. The initial location is Safe, which corresponds to a train not approaching yet. The location has no invariant, which means that a train may stay in this location an unlimited amount of time. When a train is approaching, it synchronises with the controller. This is done by the channel synchronisation appr! on the transition to Appr. The controller has a corresponding appr?. The clock x is reset and the parameterised variable e is set Approaching. Can be stopped. Cannot be stopped in Crossing to the identity of this train. This variable is used by the queue and the controller to know which train is allowed to continue or which trains must be stopped and later restarted. The location Appr has the invariant x ≤ 20, which has the e ect that the location must be left within 20 time units. The two outgoing transitions are guarded by the constraints x ≤ 10 and x ≥ 10, which corresponds to the two sections before the bridge: can be stopped and can not be stopped. At exactly 10, both transitions are enabled, which allows us to take into account any race conditions if there is one. If the train can be stopped (x ≤ 10) then the transition to the location Stop is taken, otherwise the train goes to location Cross. The transition to Stop is also guarded by the condition e == id and is synchronised with stop?. When the controller decides to stop a train, it decides which one (sets e) and synchronises with stop!. The location Stop has no invariant: a train may be stopped for an unlimited amount of time. It waits for the synchronisation go?. The guard e == id ensures that the right train is restarted. The model is simpliﬁed here compared to the version described in [60], namely the slowdown phase is not modelled explicitly. We can assume that a train may receive a go? synchronisation even when it is not stopped completely, which will give a non-deterministic restarting time. The location Start has the invariant x ≤ 15 and its outgoing transition has the constraint x ≥ 7. This means that a train is restarted and reaches the crossing section between 7 and 15 time units non-deterministically. The location Cross is similar to Start in the sense that it is left between 3 and 5 time units after entering it. (stopping) train1 (stopped) train2  (restarting) train3  Fig. 14. Now train4 has crossed the bridge and sends a leave! signal. The controller can now let train3 cross the bridge with a go! signal. Train2 is now waiting and train1 is stopping. train4:leave! Controller The Template of the Gate The gate controller in Fig. 15 synchronises with the queue and the trains. Some of its locations do not have names. Typically, they are committed locations (marked with a c). The controller starts in the Free location (i.e., the bridge is free), where it tests the queue to see if it is empty or not. If the queue is empty then the controller waits for approaching trains (next location) with the appr? synchronisation. When a train is approaching, it is added to the queue with the add! synchronisation. If the queue is not empty, then the ﬁrst train on the queue (read by hd!) is restarted with the go! synchronisation. In the Occ location, the controller essentially waits for the running train to leave the bridge (leave?). If other trains are approaching (appr?), they are stopped (stop!) and added to the queue (add!). When a train leaves the bridge, the controller removes it from the queue with the rem? synchronisation. The Template of the Queue The queue in Fig. 16 has essentially one location Start where it is waiting for commands from the controller. The Shiftdown location is used to compute a shift of the queue (necessary when the front element is removed). This template uses an array of integers and handles it as a FIFO queue. 4.3 Veriﬁcation We check simple reachability, safety, and liveness properties, and for absence of deadlock. The simple reachability properties check if a given location is reachable: – E<> Gate.Occ: the gate can receive and store messages from approaching trains in the queue. – E<> Train1.Cross: train 1 can cross the bridge. We check similar properties for the other trains. – E<> Train1.Cross and Train2.Stop: train 1 can be crossing the bridge while train 2 is waiting to cross. We check for similar properties for the other trains. – E<> Train1.Cross && Train2.Stop && Train3.Stop && Train4.Stop is similar to the previous property, with all the other trains waiting to cross the bridge. We have similar properties for the other trains. The following safety properties must hold for all reachable states: – A[] Train1.Cross+Train2.Cross+Train3.Cross+Train4.Cross<=1. There is not more than one train crossing the bridge at any time. This expression uses the fact that Train1.Cross evaluates to true or false, i.e., 1 or 0. – A[] Queue.list[N-1] == 0: there can never be N elements in the queue, i.e., the array will never overﬂow. Actually, the model deﬁnes N as the number of trains + 1 to check for this property. It is possible to use a queue length matching the number of trains and check for this property instead: A[] (Gate.add1 or Gate.add2) imply Queue.len < N-1 where the locations add1 and add2 are the only locations in the model from which add! is possible. The liveness properties are of the form Train1.Appr --> Train1.Cross: whenever train 1 approaches the bridge, it will eventually cross, and similarly for the other trains. Finally, to check that the system is deadlock-free, we verify the property A[] not deadlock. Suppose that we made a mistake in the queue, namely we wrote e:=list[1] in the template IntQueue instead of e:=list[0] when reading the head on the transition synchronised with hd?. We could have been confused when thinking in terms of indexes. It is interesting to note that the properties still hold, except list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 16. Queue automaton of the train gate. The template is parameterised with int[0,n] e. the liveness ones. The veriﬁcation gives a counter-example showing what may happen: a train may cross the bridge but the next trains will have to stop. When the queue is shifted the train that starts again is never the ﬁrst one, thus the train at the head of the queue is stuck and can never cross the bridge. 5 Example 2: Fischer’s Protocol 5.1 Description Fischer’s protocol is a well-known mutual exclusion protocol designed for n processes. It is a timed protocol where the concurrent processes check for both a delay and their turn to enter the critical section using a shared variable id. 5.2 Modelling in Uppaal The automaton of the protocol is given in Fig. 17. Starting from the initial location (marked with a double circle), processes go to a request location, req, if id==0, which checks that it is the turn for no process to enter the critical section. Processes stay non-deterministically between 0 and k time units in req, and then go to the wait location and set id to their process ID (pid). There it must wait at least k time units, x>k, k being a constant (2 here), before entering the critical section CS if it is its turn, id==pid. The protocol is based on the fact that after (strict) k time units with id di erent from 0, all the processes that want to enter the critical section are waiting to enter the critical section as well, but only one has the right ID. Upon exiting the critical section, processes reset id to allow other processes to enter CS. When processes are waiting, they may retry when another process exits CS by returning to req. x>k, id==pidcs wait Fig. 17. Template of Fischer’s protocol. The parameter of the template is const pid. The template has the local declarations clock x; const k 2;. 5.3 Veriﬁcation The safety property of the protocol is to check for mutual exclusion of the location CS: A[] P1.cs + P2.cs + P3.cs + P4.cs <= 1. This property uses the trick that these tests evaluate to true or false, i.e., 0 or 1. We check that the system is deadlock-free with the property A[] not deadlock. The liveness properties are of the form P1.req --> P1.wait and similarly for the other processes. They check that whenever a process tries to enter the critical section, it will always eventually enter the waiting location. Intuitively, the reader would also expect the property P1.req --> P1.cs that similarly states that the critical section is eventually reachable. However, this property is violated. The interpretation is that the process is allowed to stay in wait for ever, thus there is a way to avoid the critical section. Now, if we try to ﬁx the model and add the invariant x <= 2*k to the wait location, the property P1.req --> P1.cs still does not hold because it is possible to reach a deadlock state where P1.wait is active, thus there is a path that does not lead to the critical section. The deadlock is as follows: P1.wait with 0 ≤ x ≤ 2 and P4.wait with 2 ≤ x ≤ 4. Delay is forbidden in this state, due to the invariant on P4.wait and P4.wait can not be left because id == 1. 6 Example 3: The Gossiping Girls 6.1 Description Let n girls have each a private secret they wish to share with each other. Every girl can call another girl and after a conversation, both girls know mutually all their secrets. The problem is to ﬁnd out how many calls are necessary so that all the girls know all the secrets. A variant of the problem is to add time to conversations and ask how much time is necessary to exchange all the secrets, allowing concurrent calls. The basic formulation of the problem is not timed and is typically a combinatorial problem with a string of n bits that may take (at most) 2n values for every girl. That means we have in total a string of n2 bits taking 2n 2 values (in product with other states of the system). 6.2 Modelling in Uppaal We face choices regarding the representation of the secrets and where to store them. One way is to use one integer and manually set or reset its bits using arithmetic operations. Although the size of the system is limited by the size of the integers, a quick complexity evaluation shows that the state-space explodes too quicly anyway so this is not really a limitation. Another way is to use an array of booleans. The solution with the integer sounds like hacking and in fact it is so specialized that we will have problem to reﬁne the model later. The model with booleans is certainly more readable, which is desirable for formal veriﬁcation. The second choice is where to store the messages: in one big shared table locally with every girl process. The referenced models are available at http://www.cs.aau.dk/~adavid/UPPAAL-tutorial/. Generic Declarations The global declaration contains: const int GIRLS = 4; typedef int[0,GIRLS-1] girl_t; chan phone[girl_t], reply[girl_t]; This allows us to scale the model easily. Notice that it is possible to declare that arrays of channels are indexed by a given type, which implicitely gives them the right size. This is necessary to use symmetry reduction through scalar sets later. The girl process is named Girl and has girl t id as parameter. Every girl has a di erent ID. The system declaration is simply: system Girl;. This makes use of the auto-instantiation feature of Uppaal. All instances of the template Girl ranging over its parameters are generated. The number of instances is controlled by the constant GIRLS. Flexible Modelling We declare three local functions to the template Girl. Notice that they have access to the parameter id. These functions are used to initialize the template (start()) with a unique secret and to send and receive secrets to other templates (talk() and listen()). We can change these functions but still keep the same model, which makes the model ﬂexible. Integers The encoding with integers has meta int tmp; added to the global declarations and the following to the local declaration of the template Girl: girl_t g; int secrets; void start() { secrets = 1 << id; } void talk() { tmp = secrets; } void listen() { secrets |= tmp; } Initialization is done by setting bit id to one. The initial committed location ensures all girls are initialized before they start to exchange secrets. Then we have a standard message passing using a shared variable with the receiver merging the secrets sent with her own (logical or). The shared variable is declared meta, which means it is a special temporary variable not part of the state, i.e., never refer to such a variable between two states. We assume that these functions are used with channel synchronization. Booleans The encoding with booleans has meta bool tmp[girl t]; added to the global declarations and the following to the local declarations of the template Girl: girl_t g; bool secrets[girl_t]; void start() { secrets[id] = true; } void talk() { tmp = secrets; } void listen() { for(i:girl_t) secrets[i] |= tmp[i]; } In this version we use assignment between arrays for talk(). The function listen() uses an iterator. The automaton for models gossip0.xml (with integers) and gossip1.xml (with booleans) is given in Fig. 18. This ﬁrst attempt captures the fact that we want the model to be symmetric with respect to sending and receiving and is quite natural with symmetric uses of talk() and listen(). The local variable g records which other girl is a given template communicating with. The sender selects its receiver and the receiver its sender. start() Ringing j : girl_t j : girl_t id != j phone[j]? phone[j]! listen(), g = j, g = j talk() Reply Listen Fig. 18. First attempt for modelling the gossiping girls. Let us ﬁrst improve the model on three points: 1. The intermediate state Listen should be made committed otherwise all interleaving of half-started and complete calls will occur. 2. One select is enough because we are modelling something else here, namely girl id selects a channel j and any other girl that selects the same channel can communicate with id. 3. The local variable g contributes badly to the state-space when its value is not relevant, i.e., the previous communication does not need to be kept. We can set it in a symmetric manner upon the start and reset it after communication to id. These are typical “optimizations” of a model: Avoid useless interleavings by using committed locations, make sure you model exactly what you need and not more, and “active variable reduction”. The updated model (gossip2.xml/integers, gossip3.xml/booleans) is shown in Fig. 19. The template keeps as an invariant that the variable g is always equal to id whenever it is not sending. In addition, when a channel j is selected, then it corresponds to exactly girl j. Only one committed location is enough but it is a good practice to mark them both. It is more explicit when we read the model. Since the model performs better, we can now check with 5 girls instead of 4 within roughly the same time, which is a very good improvement considering the exponential complexity of the model. start(), g = id Ringing reply[id]! Replytalk() Fig. 19. Improved model of the gossiping girls. Optimizing Further We can abstract which communication line is used by declaring only one channel chan call. Since the semantics says that any pair of enabled edges (call!,call?) can be taken, we do not need to make an extra select. In addition, processes cannot synchronize with themselves so we do not need this check either. The downside is that we lose the information on the receiver from the sender point of view. We do not need this in our case. We can get rid of the local variable g as well. We could use the sequence talk()-listen()-talk()-listen() with the old functions but we can simplify these by merging the middle listen()-talk() into one and simplifying listen() to a simple assignment since we know that the message already contains the secrets sent. The global declaration is updated with only chan call; for the channel. The updated automaton is depicted in Fig. 20. The integer version of the model (gossip4.xml) has the following local functions: reply[g]? listen(), g = id start() Ringing Listen int secrets; void start() { secrets = 1 << id; } void talk() { tmp = secrets; } void exchange() { secrets = (tmp |= secrets); } void listen() { secrets = tmp; } The boolean version of the model (gossip5.xml) is changed to: bool secrets[girl_t]; void start() { secrets[id] = true; } void talk() { tmp = secrets; } void exchange() { for(i:girl_t) tmp[i] |= secrets[i]; secrets = tmp; } void listen() { secrets = tmp; } The exchange function could have been written as void exchange() { for(i:girl_t) secrets[i] = (tmp[i] |= secrets[i]); } which is almost the same. The di erence is that the number of interpreted instructions is lower in the ﬁrst case. A step further would be to inline these functions on the edges in the model but then we would lose readability to gain less than 5% in speed. It is possible to further optimize the model by having one parameterized shared table and avoid message passing all-together. We leave this as an exercise for the reader but we notice that this change destroys the nice design with the local secrets to each process. 6.3 Veriﬁcation We check the property that all girls know all secrets. For the integer version of the model, the property is: E<> forall(i:girl_t) forall(j:girl_t) (Girl(i).secrets & (1 << j)) We can write a shorter but less obvious equivalent formula that takes advantage of the fact that 2GIRLS − 1 generates a bit mask with the ﬁrst GIRLS bits set to one: E<> forall(i:girl_t) Girl(i).secrets == ((1 << GIRLS)-1) The formula for the boolean version is: E<> forall(i:girl_t) forall(j:girl_t) Girl(i).secrets[j] The formulas use the “for-all” construct, which gives compact formulas that automatically scale with the number of girls in the model. The version with the integers checks with a bit mask that the bits are set. Table 1 shows the resource consumption for the di erent models with di erent number of girls. Experiments are run on an AMD Opteron 2.2GHz with Uppaal rev. 2842. The results show how important it is to be careful with the model and Girls  4  5  6  gossip0 gossip1 gossip2 gossip3 gossip4 gossip5  0.6s/24M 1.0s/24M 0.1s/1.3M 0.1s/1.3M 0.1s/1.3M 0.1s/1.3M  498s/3071M 809s/3153M 0.3s/22M 0.5s/22M 0.2s/22M 0.3s/22M  --71s/591M 106s/607M 37s/364M 63s/381M  Table 1. Resource consumption for the di erent models with di erent number of girls. Results are in seconds/Mbytes. to optimize the model to reduce the state-space whenever possible. We notice that we do not even have time in this model. The model with integers is faster due to its simplicity but consumes marginally less memory. 6.4 Improved Veriﬁcation Uppaal features two major techniques to improve veriﬁcation. These techniques concern directly veriﬁcation and are orthogonal to model optimization. The ﬁrst is symmetry reduction. Since we designed our model to be symmetric from the start, taking advantage of this feature is done by using a scalar set for the type girl t. The second feature is the generalized sweep-line method. We need to deﬁne a progress measure to help the search. Furthermore, only the model with booleans is eligible for symmetry reduction since we cannot access individual bits in an integers in a symmetric manner (using scalars). Symmetry Reduction The only change required is for the deﬁnition of the type girl t. We use a scalar set for the new model (gossip6.xml): typedef scalar[GIRLS] girl_t; Sweep-line We need to deﬁne a progress measure that is cheap to compute and relevant to help the search. It is important that it is cheap to compute since it will be evaluated for every state. To do so, we add int m; to the global declarations, we add the progress measure deﬁnition after the system declaration: progress { m; } Finally, we compute m in the exchange function as follows: void exchange() { m =0; for(i:girl_t) { m += tmp[i] ^ secrets[i]; tmp[i] |= secrets[i]; } } This measures counts the number of new messages exchanged per communication. Girls  4  5  6  7  gossip6 gossip7  0.1s/1.3M 0.1s/1.3M  0.1s/1.3M 0.1s/1.3M  3.4s/29M 0.3s/21M  399s/1115M 29s/108M  Table 2. Resource consumption using symmetry reduction (gossip6) combined with the sweep-line method (gossip7). Table 2 show that these features give gains with another order of magnitude both in speed and memory. The model still explodes exponentially but we cannot avoid it given its nature. 7 Modelling Patterns In this section we present a number of useful modelling patterns for Uppaal. A modelling pattern is a form of designing a model with a clearly stated intent, motivation and structure. We observe that most of our Uppaal models use one or more of the following patterns and we propose that these patterns are imitated when designing new models. 7.1 Variable Reduction Intent To reduce the size of the state space by explicitly resetting variables when they are not used, thus speeding up the veriﬁcation. Motivation Although variables are persistent, it is sometimes clear from the way a model behaves, that the value of a variable does not matter in certain states, i.e., it is clear that two states that only di er in the values of such variables are in fact bisimilar. Resetting these variables to a known value will make these two states identical, thus reducing the state space. Structure The pattern is most easily applied to local variables. Basically, a variable v is called inactive in a location l, if along all paths starting from l, v will be reset before it will be used. If a variable v is inactive in location v, one should reset v to the initial value on all incoming edges of l. The exception to this rule is when v is inactive in all source locations of the incoming edges to l. In this case, v has already been reset, and there is no need to reset it again. The pattern is also applicable to shared variables, although it can be harder to recognise the locations in which the variable will be inactive. For clocks, Uppaal automatically performs the analysis described above. This process is called active clock reduction. In some situations this analysis may fail, since Uppaal does not take the values of non-clock variables into account when analysing the activeness. In those situations, it might speed up the veriﬁcation, if the clocks are reset to zero when it becomes inactive. A similar problem arises if you use arrays of clocks and use integer variables to index into those arrays. Then Uppaal will only be able to make a coarse approximation of when clocks in the array will be tested and reset, often causing the complete array to be marked active at all times. Manually resetting the clocks might speed up veriﬁcation. Sample The queue of the train gate example presented earlier in this tutorial uses the active variable pattern twice, see Fig. 21: When an element is removed, all the remaining elements of the list are shifted by one position. At the end of the loop in the Shiftdown location, the counter variable i is reset to 0, since its value is no longer of importance. Also the freed up element list[i] in the list is reset to zero, since its value will never be used again. For this example, the speedup in veriﬁcation gained by using this pattern is approximately a factor of 5. Known Uses The pattern is used in most models of some complexity. 7.2 Synchronous Value Passing Intent To synchronously pass data between processes. Motivation Consider a model of a wireless network, where nodes in the network are modelled list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 21. The model of the queue in the train gate example uses active variable reduction twice. Both cases are on the edge from Shiftdown to Start: The freed element in the queue is reset to the initial value and so is the counter variable i. as processes. Neighbouring nodes must communicate to exchange, e.g., routing information. Assuming that the communication delay is insigniﬁcant, the handshake can be modelled as synchronisation via channels, but any data exchange must be modelled by other means. The general idea is that a sender and a receiver synchronise over shared binary channels and exchange data via shared variables. Since Uppaal evaluates the assignment of the sending synchronisation ﬁrst, the sender can assign a value to the shared variable which the receiver can then access directly. Structure There are four variations of the value passing pattern, see Fig. 22. They di er in whether data is passed one-way or two-way and whether the synchronisation is unconditional or conditional. In one-way value passing a value is transfered from one process to another, whereas two-way value passing transfers a value in each direction. In unconditional value passing, the receiver does not block the communication, whereas conditional value passing allows the receiver to reject the synchronisation based on the data that was passed. In all four cases, the data is passed via the globally declared shared variable var and synchronisation is achieved via the global channels c and d. Each process has local variables in and out. Although communication via channels is always synchronous, we refer to a c! as a send-action and c? as a receive-action. Notice that the variable reduction pattern is used to reset the shared variable when it is no longer needed. Alternatively, the shared variable can be declared meta, in which case the reset is not necessary since the variable is not part of the state. In one-way value passing only a single channel c and a shared variable var is required. The sender writes the data to the shared variable and performs a send-action. The receiver performs the co-action, thereby synchronising with the sender. Since the update on the edge with send-action is always evaluated before the update of the edge with the receive-action, the receiver can access the data written by the sender in the same transition. In the conditional case, the receiver can block the synchronisation according to some predicate cond(in) involving the value passed by the sender. The intuitive placement of this predicate is on the guard of the receiving edge. Unfortunately, this will not work as expected, since the guards of the edges are evaluated before the updates are executed, i.e., before the receiver has access to the value. The solution is to place the predicate on the invariant of the target location. Unconditio nal  Conditional  One-way c! var := out ‚ ‚ ‚ ‚ ‚  c? in := var, var := 0  c! var := out ‚ ‚ ‚ ‚ ‚  c? in := var, var := 0 cond(in)  Asymmetric two-way c! var := out d? in := var, var :=0 ‚ ‚ ‚ ‚ ‚  c? in := var d! var := out  c! var := out ‚ ‚ ‚ ‚ ‚ cond1(var) d? in := var, var :=0  c? in := var, var := out cond2(in) d!  Fig. 22. The are essentially four combinations of conditional, unconditional, one-way and two-way synchronous value passing. Two-way value passing can be modelled with two one-way value passing pattern with intermediate committed locations. The committed locations enforce that the synchronisation is atomic. Notice the use of two channels: Although not strictly necessary in the two-process case, the two channel encoding scales to the case with many processes that non-deterministically choose to synchronise. In the conditional case each process has a predicate involving the value passed by the other process. The predicates are placed on the invariants of the committed locations and therefore assignment to the shared variable in the second process must be moved to the ﬁrst edge. It might be tempting to encoding conditional two-way value passing directly with two one-way conditional value passing pattern, i.e., to place the predicate of the ﬁrst process on the third location. Unfortunately, this will introduce spurious deadlocks into the model. If the above asymmetric encoding of two-way value passing is undesirable, the symmetric encoding in Fig. 23 can be used instead. Basically, a process can nondeterministically choose to act as either the sender or the receiver. Like before, committed locations guarantee atomicity. If the synchronisation is conditional, the predicates are placed on the committed locations to avoid deadlocks. Notice that the symmetric encoding is more expensive: Even though the two paths lead to the same result, two extra successors will be generated. c! c? var := out in := var, var := out cond(var) cond(in) d? d! in := var, var := 0 Fig. 23. In contrast to the two-way encoding shown in Fig 22, this encoding is symmetric in the sense that both automata use the exact same encoding. The symmetry comes at the cost of a slightly larger state space. Sample The train gate example of this tutorial uses synchronous one-way unconditional value passing between the trains and the gate, and between the gate and the queue. In fact, the value passing actually happens between the trains and the queue and the gate only act as a mediator to decouple the trains from the queue. Known Uses Lamport’s Distributed Leader Election Protocol. Nodes in this leader election protocol broadcast topology information to surrounding nodes. The communication is not instantaneous, so an intermediate process is used to model the message. The nodes and the message exchange data via synchronous one-way unconditional value passing. Lynch’s Distributed Clock Synchronisation Protocol. This distributed protocol synchronises drifting clocks of nodes in a network. There is a fair amount of non-determinism on when exactly the clocks are synchronised, since the protocol only required this to happen within some time window. When two nodes synchronise non-deterministically, both need to know the other nodes identity. As an extra constraint, the synchronisation should only happen if it has not happened before in the current cycle. Here the asymmetric two-way conditional value passing pattern is used. The asymmetric pattern suÿces since each node has been split into two processes, one of them being dedicated to synchronising with the neighbours. 7.3 Synchronous Value Passing (bis) Intent To synchronously pass integers with a small range between processes. Motivation Similarly to the previous value passing pattern, it is useful to send values between processes. However, this pattern is specialized to integers with small ranges, which gives us the beneﬁt to avoid using a shared variable for the communication. Structure The idea is to use arrays of channels to pass speciﬁc integers. The pattern is given for the general case of passing an integer value between MIN and MAX. Declare the array chan send[MAX-MIN+1] with MAX and MIN being either constants or the actual value of the desired range. Figure 7.3 shows the pattern. As an example the sender is sending the values 2, 3, or a randomly chosen value. The receiver is using the select feature of Uppaal 3.6 to ﬁnd the right value. Notice that this is expensive for the model-checker if the range is large and will degrade performance. Two-way value passing can be modeled similarly to the previous pattern with the shared variable removed. Conditional value passing works for one-way only. send[3-MIN]! send[2-MIN]! send[random-MIN]! ‚‚‚‚‚ i:int[MIN,MAX] send[i-MIN]? value=i random:int[MIN,MAX] sent received (a) Sender. (b) Receiver. Fig. 24. Value passing using an array of channels. 7.4 Multicast Intent To encode multicast to at least N receivers (or similarly exactly N ). Motivation Uppaal provides pair-wise synchronisation via regular channels (chan) and broadcast synchronisation via broadcast channels (broadcast chan). In some models it is useful to ensure there are at least N receivers available and have the multicast behaviour, typically for communication protocols. Structure Use a shared variable (e.g. ready) that is incremented on the edges leading to a location where it is possible to receive and decrement this variable on the edges that leave this location. In addition, add the constraint in the sender process on the required number of receiver (e.g. ready >= N ). Figure 7.4 illustrates the patter. doSomething ready++ waitN waiting ready >= 3 sentN received multisend? multisend! ‚‚‚‚‚ready-(a) Sender. (b) Receiver. Fig. 25. Multicast from one sender to at least N receivers (3 in this example). 7.5 Atomicity Intent To reduce the size of the state space by reducing interleaving using committed locations, thus speeding up the veriﬁcation. Motivation Uppaal uses an asynchronous execution model, i.e., edges from di erent automata can interleave, and Uppaal will explore all possible interleavings. Partial order reduction is an automatic technique for eliminating unnecessary interleavings, but Uppaal does not support partial order reduction. In many situations, unnecessary interleavings can be identiﬁed and eliminated by making part of the model execute in atomic steps. Structure Committed locations are the key to achieving atomicity. When any of the processes is in a committed location, then time cannot pass and at least one of these processes must take part in the next transition. Notice that this does not rule out interleaving when several processes are in a committed location. On the other hand, if only one process is in a committed location, then that process must take part in the next transition. Therefore, several edges can be executed atomically by marking intermediate locations as committed and avoiding synchronisations with other processes in the part that must be executed atomically, thus guaranteeing that the process is the only one in a committed location. Sample The pattern is used in the Queue process of the train gate example, see Fig. 26. list[len]:=e, add? len++notempty! len>0 empty! len==0 rem! len>=1 len--, i := 0 i < len list[i]:=list[i+1], i++ Fig. 26. When removing the front element from the queue, all other elements must be shifted down. This is done in the loop in the Shiftdown location. To avoid unnecessary interleavings, the location is marked committed. Notice that the edge entering Shiftdown synchronises over the rem channel. It is important that target locations of edges synchronising over rem in other processes are not marked committed. Known Uses Encoding of control structure A very common use is when encoding control structures (like the encoding of a for-loop used in the IntQueue process of the train-gate example): In these cases the interleaving semantics is often undesirable. Multi-casting Another common use is for complex synchronisation patterns. The standard synchronisation mechanism in Uppaal only supports binary or broadcast synchronisation, but by using committed locations it is possible to atomically synchronise with several processes. One example of this is in the train-gate example: Here the Gate process acts as a mediator between the trains and the queue, ﬁrst synchronising with one and then the other – using an intermediate committed location to ensure atomicity. 7.6 Urgent Edges Intent To guarantee that an edge is taken without delay as soon as it becomes enabled. Motivation Uppaal provides urgent locations as a means of saying that a location must be left without delay. Uppaal provides urgent channels as a means of saying that a synchronisation must be executed as soon as the guards of the edges involved are enabled. There is no way of directly expressing that an edge without synchronisation should be taken without delay. This pattern provides a way of encoding this behaviour. Structure The encoding of urgent edges introduces an extra process with a single location and a self loop (see Fig. 27 left). The self loop synchronises on the urgent channel go. An edge can now be made urgent by performing the complimentary action (see Fig. 27 right). The edge can have discrete guards and arbitrary updates, but no guards over clocks. go!‚‚‚‚‚ go? Fig. 27. Encoding of urgent edges. The go channel is declared urgent. Sample This pattern is used in a model of a box sorting plant (see http://www.cs.auc. dk/∼behrmann/esv03/exercises/index.html#sorter): Boxes are moved on a belt, registered at a sensor station and then sorted by a sorting station (a piston that can kick some of the boxes of the belt). Since it takes some time to move the boxes from the sensor station to the sorting station, a timer process is used to delay the sorting action. Figure 28 shows the timer (this is obviously not the only encoding of a timer – this particular encoding happens to match the one used in the control program of the plant). The timer is activated by setting a shared variable active to true. The timer should then move urgently from the passive location to the wait location. This is achieved by synchronising over the urgent channel go. x==ctime eject! active:=false x<=ctime active==true go? Fig. 28. Sample of a timer using an urgent edge during activation. 35 7.7 Timers Intent To emulate a timer where, in principle, time decreases until it reaches zero, at which point the timer is said to time-out. Motivation Although clocks are powerful enough to model timing mechanisms, some systems are more naturally modelled using timers, in particular event based models. In such models, a timer is started, may be restarted, and counts down until a time-out event is generated. Structure The pattern gives an equivalent of a timer object mapped on a process in Uppaal. We deﬁne the following operations for a timer object t: – void set(TO): this function starts or restarts the timer with a time-out value of TO. The timer will count down for TO time units. TO is an integer. – bool expired(): this function returns true if the timer has expired, false otherwise. When the timer has not been started yet, it is said to have expired. This function may be called at any time to test the timer. We map the above deﬁned timer as a process in Uppaal. When a timer t is to be used in the model, its functions are mapped as follows: – t.set(v) where v is an integer variable is mapped to the synchronisation set! and the assignment value := v, where the channel set and the integer value are the parameters of the timer template. – t.expired() is mapped to the guard value == 0, where value is a parameter of the timer template. As a variant of this basic timer model, it is possible to generate a time-out synchronisation, urgent or not depending on the needs, by using the pattern to encode urgent edges shown in Fig. 27. If the time-out value is a constant, we can optimise the coding to: – t.set() (no argument since the time-out is a constant) is mapped to set!. – t.expired() is mapped to active == false where active is a parameter of the template. The templates are shown in Fig. 29. The two states correspond to the timer having expired (timer inactive) and waiting to time-out (timer active). The template (a) makes use of a feature of Uppaal to mix integers and clocks in clock constraints. The constraint is dynamic and depends on the value of the integer. When returning to the state Expired, the timer resets its value, which has the e ect to (1) use variable reduction (see pattern 7.1) and (2) to provide a simple way to test for a time-out. The template (b) is simpler in the sense that a constant is used in the clock constraints. Testing for the time-out is equivalent to test on the boolean variable active. set? set? x:=0 Waiting x:=0, active:=true Waiting (a) Timer with variable time-out. (b) Timer with constant time-out. Fig. 29. Template of the timer pattern. Template (a) has int value; chan set as parameters and template (b) has bool active; chan set; const TO as parameters. Both templates have the local declaration clock x. Known Uses A variation of the timer pattern is used in the box sorting machine of the previous pattern (for educational purposes reconstructed in Lego): A timer is activated when a coloured brick passes a light sensor. When the timer times out a piston kicks the brick from the transport belt. 7.8 Bounded Liveness Checking Intent To check bounded liveness properties, i.e., properties that are guaranteed not only to hold eventually but within some speciﬁed upper time-bound. Time-bounded liveness properties are essentially safety properties and hence often computationally easier to verify. Thus moving from (unconditional) liveness properties to a time-bounded versions will not only provide additional information — i.e., if one can provide a valid bound — but will also lead to more eÿcient veriﬁcation. Motivation For real-time systems general liveness properties are often not suÿciently expressive to ensure correctness: the fact that a particular property is guaranteed to hold eventually is inadequate in case hard real-time deadlines must be observed. What is really needed is to establish that the property in question will hold within a certain upper time-limit. Structure We consider two variations of the pattern for a time-bounded leads-to operator ϕ ;≤t ψ expressing that whenever the state property ϕ holds then the state property ψ must hold within at most t time-units thereafter. In the ﬁrst version of the pattern we use a simple reduction for unbounded leads-to. First the model under investigation is extended with an additional clock z which is reset whenever ϕ starts to hold. The time-bounded leads-to property ϕ ;≤t ψ is now simply obtained by verifying ϕ ; (ψ ∧ z ≤ t). In the second — and more eÿcient version — of the pattern we use the method proposed in [54] in which time-bounded leads-to properties are reduced to simple safety properties. First the model under investigation is extended with a boolean variable b and an additional clock z. The boolean variable b must be initialised to false. Whenever ϕ starts to hold b is set to true and the clock z is reset. When ψ commences to hold b is set to false. Thus the truth-value of b indicates whether there is an obligation of ψ to hold in the future and z measures the accumulated time since this unfulﬁlled obligation started. The time-bounded leads-to property ϕ ;≤t ψ is simply obtained by verifying the safety property A2(b =⇒ z ≤ t). A third method not reported is based on augmenting the model under investigation with a so-called test-automata, see [2,1]. We have deliberately been somewhat vague about the exact nature of the required augmentation of the model. The most simple case is when the (state) properties ϕ and ψ are simple locations l and l ′ of component automata. In this simple case the settings of z and b are to be added as assignments of the edges entering l and l ′ . Sample In the train gate example presented earlier in this tutorial a natural requirement is that a train is granted access to the crossing within a certain upper time-bound (say 100) after having signalled that it is approaching. In fact, not only is the gate responsible for avoiding collisions on the crossing but also for ensuring a fair and timely handling of requests. In Fig. 30 the Train template has been augmented with a local boolean b and a local clock z. b (to be initialised to 0) is set to 1 on the transition to location Appr and set to 0 on the two transitions to Cross. The clock z is reset on the transition to Appr. On the augmented model we now check the safety property A[](Train1.b==1 imply Train1.z<=100) which establishes that the bounded liveness property holds for Train1. In fact — due to obvious symmetries in the model — it suÿces to establish the property for one train, Train1 say. In this case it would have been advantageous for Train1 to be singleton template in order to avoid augmenting all trains. In particular, the state-space will be substantially smaller in this way. Known Uses Almost any real-time system will have a number of liveness properties where information as to the time-bounds is vital for the correctness of the systems. The Gearbox Controller of [54] o ers an excellent example where a long list of time-bounded liveness properties are directly obtained from requirements speciﬁed by the company Mecel AB. 7.9 Abstraction and Simulation Intent The goal of abstraction is to replace the problem of verifying a very large, infeasible concrete system with a smaller, and hopefully feasible abstract system. In particular, the method could be applied in a compositional manner to subsystems, i.e., various concrete subsystems are replaced by suitable abstractions, e:=id, x:=0 x>=3Safe Cross x<=5 appr! x:=0, b:=0e:=id, x:=0, z:=0, x>=7 b:=1 Appr Start x<=20 x<= 15 x<=10, x:=0e==id go?stop? e==id x:=0 Stop Fig. 30. The Train-Gate augmented to enable time-bounded liveness checking. and the veriﬁcation e ort is conducted on the composition of these abstract subsystems. Motivation Despite enormous improvement in the veriﬁcation capabilities of Uppaal over the past years — and undoubtedly also for the years to come — state-space explosion is an ever existing problem that will be solved by algorithmic advances.9 However, in verifying speciﬁc properties of a systems it is often only part of the behaviour of the various components which is relevant. Often the designer will have a good intuition about what these relevant parts are, in which case (s)he is able to provide abstractions for the various components, which are still concrete enough that the given property holds, yet are abstract (and small) enough that the veriﬁcation e ort becomes feasible. To give a sound methodology two requirements should be satisﬁed. Firstly, the notion of abstraction applied should preserve the properties of interest, i.e., once a property has been shown to hold for the abstraction it should be guaranteed to also hold for the concrete system. Secondly, the abstraction relation should be preserved under composition of systems. In [46,45] we have put forward the notion of (ready) timed simulation preserving safety properties while being a pre-congruence w.r.t. composition. Moreover, for (suggested) abstractions being deterministic and with no internal transitions, timed simulation may be established using simple reachability checking (and hence by using Uppaal). Structure Let A be a timed automaton suggested as an abstraction for some (sub)system 9 unless we succeed in showing P=PSPACE S (possibly a network of timed automata). We assume that A is deterministic (i.e., no location with outgoing edges having overlapping guards) and without any internal transitions. For simplicity we shall assume all channels to be non-urgent and no shared variables exist between S and the remaining system. The extension of the technique to allow for urgency and shared variables can be found in [46]. To show that A is indeed an abstraction of S in the sense that A (ready) timed simulates S a test-automata TA is constructed in the following manner: TA has A as a skeleton but with the direction of actions (input/output) reversed. A distinguished new location bad is added and from all locations l and all actions a an a-labelled edge from l to bad is inserted with guard ¬(g1 ∨ ... ∨ gn) where g1 ...gn is the full set of guards of a-labelled edges out of l in the skeleton. Now S is (ready) timed simulated by A — and hence A is a valid abstraction of S — precisely if the location bad is unreachable in the composite system STA. Essentially, TA observes that all behaviour of S is matchable by A. Sample Consider the Uppaal model in Fig. 31 consisting of a Sender a Receiver and four pipelining processes Pi. Each pipeline process Pi has the obligation of reacting to a stimulus from its predecessor on channel ai and pass it on to its successor on channel ai+1. A local clock is used to model that each pipeline process adds a minimum delay of 2. After having completed the passing on, the pipeline process engages in some internal computation (the small cycle S2, S3, S4). Now assume that we want to verify that the Receiver will have received its stimulus no sooner than after 8 time-units, or in general 2n in a system with n pipeline processes. Obviously, the system we are looking at is subject to an enormous state-space explosion when we increase the number of pipeline elements. However, for establishing the property in question we need only little information about the various subsystems. For P1P2 we essentially only need to know that the time from reacting to the initial stimulus from the Sender to passing this stimulus on to P3 is at least 4. We do not need to worry about the internal computation nor the precise moment in time when the stimulus was passed from P1 to P2. In particular we should be able to replace P1P2 with the much simpler automaton P1P2. To show that this is a valid substitution we simply show that the BAD location is unreachable for the system P1P2TestP1P2, where TestP1P2 is the test automaton for P1P2. A similar abstraction P3P4 may obviously be given for the subsystem P3P4 and the desired property may now be established for the “much” simpler system P1P2P3P4, rather than the original system. Known Uses The described technique can be found in full details in the Ph.D. thesis of Jensen [45]. In [46] the technique has been successfully applied to the veriﬁcation of a protocol for controlling the switching between power on/o states in audio/video components described in [48]. Sender P1 P2 P3 P4 Receiver S0 S0S0 S0 x>=2 x>=2 x>=2 x>=2 S1 S1 S4 S4 S4 S4S3 S3 S3 S3 a1? a2? a3? a4? S0 S0x:=0 x:=0 x:=0 x:=0S1 S1 S1 S1 ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ ‚‚‚‚‚ a1! a5? a2! a3! a4! a5!S2 S2 S2 S2 S0 Fig. 32. A suggested abstraction and its test automaton. 8 Conclusion Uppaal is a research tool available for free at http://www.uppaal.com/ that features an intuitive graphical interface. It has been ported to di erent platforms and it is in constant development. There are di erent development branches and tools that make use of Uppaal: Cost–UPPAAL supports cost annotations of the model and can do minimal cost reachability analysis [51]. This version also has features for guiding the search. This version can be downloaded from http://www.cs.auc.dk/ ∼behrmann/ guiding/. Distributed–UPPAAL runs on multi-processors and clusters using the combined memory and CPU capacity of the system [17,9]. T–UPPAAL test case generator for black-box conformance testing, see http: //www.cs.auc.dk/∼marius/tuppaal/. Times is a tool set for modelling, schedulability analysis, and synthesis of (optimal) schedules and executable code. The veriﬁcation uses Uppaal [6]. On-going work on the model-checker includes support for hierarchical timed automata, symmetry reduction, U-Code (Uppaal code, large subset of C), improved memory management, etc. The tool has been successfully applied to case studies ranging from communication protocols to multimedia applications: Bang & Olufsen audio/video protocol. An error trace with more than 2000 transition steps was found [35]. TDMA Protocol Start-Up Mechanism was veriﬁed in [55]. Bounded retransmission protocol over a lossy channels was veriﬁed in [24]. Lip synchronisation algorithm was veriﬁed in [23]. Power-down controller in an audio/video component was designed and veriﬁed in collaboration with Bang & Olufsen in [34]. Guided synthesis of control programs for a steel production plant was done in [43]. The ﬁnal control programs were compiled to run on a Lego model of the real plant. Gearbox controller was formally designed and analysed in [54]. Lego Mindstorm programs written in “Not Quite C” have been veriﬁed in [44]. Field bus protocol was modelled and analysed in [30]. Bi-phase Mark Protocol was modelled and analysed in [59] with Uppaal and PVS. Controller for a wafer scanner was designed with the aid of Uppaal in [37]. Car supervision system was formally modelled and analysed in [33]. IEEE1394a root contention protocol was modelled and veriﬁed in [58]. Uppaal is also used in a number of courses on real-time systems and formal veriﬁcation: – http://user.it.uu.se/∼paupet/#teaching Real-time and formal method courses at Uppsala University. – http://csd.informatik.uni-oldenburg.de/teaching/fp realzeitsys ws0001/ result/eindex.html Practical course “Real-Time Systems” at the University of Oldenburg. – http://fmt.cs.utwente.nl/courses/systemvalidation/ System Validation (using Model Checking) at the University of Twente. – http://www.cs.auc.dk/∼behrmann/esv03/ Embedded Systems Validation at Aalborg University. – http://www.cs.auc.dk/∼kgl/TOV04/Plan.html Test and Veriﬁcation at Aalborg University. – http://www.seas.upenn.edu/∼pappasg/EE601/F03/ Hybrid Systems at the University of Pennsylvania. – http://www.it.uu.se/edu/course/homepage/proalgebra Process Algebra at Uppsala University. – http://www.cs.auc.dk/∼luca/SV/ Semantics and Veriﬁcation. – http://www.cs.depaul.edu/programs/courses.asp?subject=SE&courseid=533 Software Validation and Veriﬁcation at DePaul University. – http://www.cs.bham.ac.uk/∼mzk/courses/SafetyCrit/ Safety Critical Systems and Software Reliability at the University of Birmingham. 42 – http://fmt.cs.utwente.nl/courses/sysontomg/ Systeem-ontwikkelomgevingen at the University of Twente. – http://www.niii.ru.nl/F.Vaandrager/PV/ Protocol Validation at the Radboud University of Nijmegen. Finally the following books have parts devoted to Uppaal: – Concepts, Algorithms and Tools for Model-Checking [47]: Lecture notes in its current form. It treats both Spin and Uppaal. – Systems and Software Veriﬁcation: Model-checking Techniques and Tools [22]: This book identiﬁes 6 important tools and has a chapter on Uppaal. References 1. Luca Aceto, Patricia Bouyer, Augusto Burgue˜no, and Kim Guldstrand Larsen. The power of reachability testing for timed automata. Theoretical Computer Science, 1–3(300):411–475, 2003. 2. Luca Aceto, Augusto Burgue˜no, and Kim G. Larsen. Model checking via reachability testing for timed automata. In Bernhard Ste en, editor, Tools and Algorithms for Construction and Analysis of Systems, 4th International Conference, TACAS ’98, volume 1384 of Lecture Notes in Computer Science, pages 263–280. Springer– Verlag, April 1998. 3. Rajeev Alur, Costas Courcoubetis, and David L. Dill. Model-checking for real-time systems. In 5th Symposium on Logic in Computer Science (LICS’90), pages 414–425, 1990. 4. Rajeev Alur and David L. Dill. Automata for modeling real-time systems. In Proc. of Int. Colloquium on Algorithms, Languages, and Programming, volume 443 of LNCS, pages 322–335, 1990. 5. Tobias Amnell, Gerd Behrmann, Johan Bengtsson, Pedro R. D’Argenio, Alexandre David, Ansgar Fehnker, Thomas Hune, Bertrand Jeannet, Kim G. Larsen, M. Oliver M¨oller, Paul Pettersson, Carsten Weise, and Wang Yi. Uppaal -Now, Next, and Future. In F. Cassez, C. Jard, B. Rozoy, and M. Ryan, editors, Modelling and Veriﬁcation of Parallel Processes, number 2067 in Lecture Notes in Computer Science Tutorial, pages 100–125. Springer–Verlag, 2001. 6. Tobias Amnell, Elena Fersman, Leonid Mokrushin, Paul Pettersson, and Wang Yi. Times – a tool for modelling and implementation of embedded systems. In TACAS 2002, volume 2280 of Lecture Notes in Computer Science, pages 460–464. Springer–Verlag, April 2002. 7. Felice Balarin. Approximate reachability analysis of timed automata. In 17th IEEE Real-Time Systems Symposium. IEEE Computer Society Press, 1996. 8. Gerd Behrmann. Data Structures and Algorithms for the Analysis of Real Time Systems. PhD thesis, Aalborg University, 2003. 9. Gerd Behrmann. Distributed reachability analysis in timed automata. Software Tool For Technology Transfer (STTT), 2004. Currently available in the Online First edition of STTT. 10. Gerd Behrmann, Johan Bengtsson, Alexandre David, Kim G. Larsen, Paul Petters-son, and Wang Yi. Uppaal implementation secrets. In Proc. of 7th International Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, 2002. 11. Gerd Behrmann, Patricia Bouyer, Kim G. Larsen, and Radek Pel¡E1¿nek. Lower and upper bounds in zone-based abstractions of timed automata. International Journal on Software Tools for Technology Transfer, September 2005. 12. Gerd Behrmann, Alexandre David, Kim G. Larsen, John H°akansson, Paul Pettersson, Wang Yi, and Martijn Hendriks. UPPAAL 4.0. In Proceedings of the 3rd International Conference on the Quantitative Evaluation of SysTems (QEST) 2006, IEEE Computer Society, pages 125–126, 2006. 13. Gerd Behrmann, Alexandre David, Kim G. Larsen, M. Oliver M¨oller, Paul Petters-son, and Wang Yi. Uppaal -present and future. In Proc. of 40th IEEE Conference on Decision and Control. IEEE Computer Society Press, 2001. 14. Gerd Behrmann, Alexandre David, Kim G. Larsen, and Wang Yi. Uniﬁcation & sharing in timed automata veriﬁcation. In SPIN Workshop 03, volume 2648 of LNCS, pages 225–229, 2003. 15. Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim G. Larsen, Paul Petters-son, and Judi Romijn. Eÿcient guiding towards cost-optimality in uppaal. In T. Margaria and W. Yi, editors, Proceedings of the 7th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, number 2031 in Lecture Notes in Computer Science, pages 174–188. Springer–Verlag, 2001. 16. Gerd Behrmann, Ansgar Fehnker, Thomas Hune, Kim G. Larsen, Paul Pettersson, Judi Romijn, and Frits Vaandrager. Minimum-cost reachability for priced timed automata. In Maria Domenica Di Benedetto and Alberto Sangiovanni-Vincentelli, editors, Proceedings of the 4th International Workshop on Hybrid Systems: Computation and Control, number 2034 in Lecture Notes in Computer Sciences, pages 147–161. Springer–Verlag, 2001. 17. Gerd Behrmann, Thomas Hune, and Frits Vaandrager. Distributed timed model checking -How the search order matters. In Proc. of 12th International Conference on Computer Aided Veriﬁcation, Lecture Notes in Computer Science, Chicago, Juli 2000. Springer–Verlag. 18. Gerd Behrmann, Kim G. Larsen, Justin Pearson, Carsten Weise, and Wang Yi. Eÿcient timed reachability analysis using clock di erence diagrams. In Proceedings of the 12th Int. Conf. on Computer Aided Veriﬁcation, volume 1633 of Lecture Notes in Computer Science. Springer–Verlag, 1999. 19. Johan Bengtsson. Clocks, DBMs and States in Timed Systems. PhD thesis, Uppsala University, 2002. 20. Johan Bengtsson, Bengt Jonsson, Johan Lilius, and Wang Yi. Partial order reductions for timed systems. In Proceedings of the 9th International Conference on Concurrency Theory, September 1998. 21. Johan Bengtsson, Kim G. Larsen, Fredrik Larsson, Paul Pettersson, Yi Wang, and Carsten Weise. New generation of uppaal. In Int. Workshop on Software Tools for Technology Transfer, June 1998. 22. Beatrice Berard, Michel Bidoit, Alain Finkel, Francois Laroussinie, Antoine Petit, Laure Petrucci, Philippe Schnoebelen, and Pierre McKenzie. Systems and Software Veriﬁcation: Model-Checking Techniques and Tools. Springer–Verlag, 2001. 23. Howard Bowman, Giorgio P. Faconti, Joost-Pieter Katoen, Diego Latella, and Mieke Massink. Automatic veriﬁcation of a lip synchronisation algorithm using uppaal. In Bas Luttik Jan Friso Groote and Jos van Wamel, editors, In Proceedings of the 3rd International Workshop on Formal Methods for Industrial Critical Systems. Amsterdam , The Netherlands, 1998. 24. Pedro .R. D’Argenio, Joost-Pieter. Katoen, Theo C. Ruys, and Jan Tretmans. The bounded retransmission protocol must be on time! In In Proceedings of the 3rd International Workshop on Tools and Algorithms for the Construction and Analysis of Systems, volume 1217 of LNCS, pages 416–431. Springer–Verlag, April 1997. 25. Alexandre David. Hierarchical Modeling and Analysis of Timed Systems. PhD thesis, Uppsala University, November 2003. 26. Alexandre David, Gerd Behrmann, Kim G. Larsen, and Wang Yi. New uppaal architecture. In Paul Pettersson and Wang Yi, editors, Workshop on Real-Time Tools, Uppsala University Technical Report Series, 2002. 27. Alexandre David, Gerd Behrmann, Kim G. Larsen, and Wang Yi. A tool architecture for the next generation of uppaal. In 10th Anniversary Colloquium. Formal Methods at the Cross Roads: From Panacea to Foundational Support, LNCS, 2003. 28. Alexandre David, John H°akansson, Kim G. Larsen, and Paul Pettersson. Model checking timed automata with priorities using dbm subtraction. In Proceedings of the 4th International Conference on Formal Modelling and Analysis of Timed Systems (FORMATS’06), volume 4202 of LNCS, pages 128–142, 2006. 29. Alexandre David, M. Oliver M¨oller, and Wang Yi. Formal veriﬁcation of UML statecharts with real-time extensions. In Ralf-Detlef Kutsche and Herbert Weber, editors, Fundamental Approaches to Software Engineering, 5th International Conference, FASE 2002, volume 2306 of LNCS, pages 218–232. Springer–Verlag, 2002. 30. Alexandre David and Wang Yi. Modelling and analysis of a commercial ﬁeld bus protocol. In Proceedings of the 12th Euromicro Conference on Real Time Systems, pages 165–172. IEEE Computer Society, 2000. 31. Ansgar Fehnker. Citius, Vilius, Melius: Guiding and Cost-Optimality in Model Checking of Timed and Hybrid Systems. PhD thesis, University of Nijmegen, April 2002. 32. Elena Fersman. A Generic Approach to Schedulability Analysis of Real-Time Systems. PhD thesis, Uppsala University, November 2003. 33. B. Gebremichael, T. Krilavicius, and Y.S. Usenko. A formal analysis of a car periphery supervision system. Technical Report NIII-R0418, Radboud University of Nijmegen, 2004. 34. Klaus Havelund, Kim G. Larsen, and Arne Skou. Formal veriﬁcation of a power controller using the real-time model checker uppaal. 5th International AMAST Workshop on Real-Time and Probabilistic Systems, available at http://www.uppaal.co m, 1999. 35. Klaus Havelund, Arne Skou, Kim G. Larsen, and Kristian Lund. Formal modelling and analysis of an audio/video protocol: An industrial case study using uppaal. In Proceedings of the 18th IEEE Real-Time Systems Symposium, pages 2–13, December 1997. 36. M. Hendriks, G. Behrmann, K.G. Larsen, P. Niebert, and F.W. Vaandrager. Adding symmetry reduction to uppaal. In Proceedings First International Workshop on Formal Modeling and Analysis of Timed Systems (FORMATS 2003), volume 2791 of Lecture Notes in Computer Science, 2003. 37. M. Hendriks, N.J.M. van den Nieuwelaar, and F.W. Vaandrager. Model checker aided design of a controller for a wafer scanner. Technical Report NIII-R0430, Radboud University of Nijmegen, 2004. 38. Martijn Hendriks and Kim G. Larsen. Exact acceleration of real-time model checking. In E. Asarin, O. Maler, and S. Yovine, editors, Electronic Notes in Theoretical Computer Science, volume 65. Elsevier Science Publishers, April 2002. 39. Thomas A. Henzinger. Symbolic model checking for real-time systems. Information and Computation, 111:193–244, 1994. 40. Gerard J. Holzmann. Design and Validation of Computer Protocols. Prentice-Hall, 1991. 41. Gerard J. Holzmann. An analysis of bitstate hashing. Formal Methods in System Design, 13:289–307, 1998. 42. John E. Hopcroft and Je rey D. Ullman. Introduction of Automata Theory, Languages, and Computation. Addison Wesley, 2001. 43. Thomas Hune, Kim G. Larsen, and Paul Pettersson. Guided synthesis of control programs using uppaal. In Ten H. Lai, editor, Proc. of the IEEE ICDCS International Workshop on Distributed Systems Veriﬁcation and Validation, pages E15–E22. IEEE Computer Society Press, April 2000. 44. Torsten K. Iversen, K°are J. Kristo ersen, Kim G. Larsen, Morten Laursen, Rune G. Madsen, Ste en K. Mortensen, Paul Pettersson, and Chris B. Thomasen. Model-checking real-time control programs — Verifying LEGO mindstorms systems using uppaal. In Proc. of 12th Euromicro Conference on Real-Time Systems, pages 147– 155. IEEE Computer Society Press, June 2000. 45. Henrik Ejersbo Jensen. Abstraction-Based Veriﬁcation of Distributed Systems. PhD thesis, Aalborg University, June 1999. 46. Henrik Ejersbo Jensen, Kim Guldstrand Larsen, and Arne Skou. Scaling up uppaal automatic veriﬁcation of real-time systems using compositionality and abstraction. In Mathai Joseph, editor, Formal Techniques in Real-Time and Fault-Tolerant Systems, 6th International Symposium, FTRTFT 2000, volume 1926 of Lecture Notes in Computer Science, pages 19–20. Springer–Verlag, 2000. 47. Joost-Pieter Katoen. Concepts, Algorithms, and Tools for Model Checking. http://www.it-c.dk/people/hra/mcpa/katoen.ps, 1999. 48. Arne Skou Klaus Havelund, Kim Guldstrand Larsen. Formal veriﬁcation of a power controller using the real-time model checker Uppaal. In 5th Int. AMAST Workshop on Real-Time and Probabilistic Systems, volume 1601 of Lecture Notes in Computer Science, pages 277–298. Springer–Verlag, 1999. 49. L.M. Kristensen and T. Mailund. A Generalised Sweep-Line Method for Safety Properties. In Proc. of FME’02, volume 2391 of LNCS, pages 549–567. Springer-Verlag, 2002. 50. K°are J. Kristo ersen. Compositional Veriﬁcation of Concurrent Systems. PhD thesis, Aalborg University, August 1998. http://www.itu.dk/people/kjk/publications.html. 51. Kim G. Larsen, Gerd Behrmann, Ed Brinksma, Ansgar Fehnker, Thomas Hune, Paul Pettersson, and Judi Romijn. As cheap as possible: Eÿcient cost-optimal reachability for priced timed automata. In G. Berry, H. Comon, and A. Finkel, editors, Proceedings of CAV 2001, number 2102 in Lecture Notes in Computer Science, pages 493–505. Springer–Verlag, 2001. 52. Kim G. Larsen, Paul Pettersson, and Wang Yi. Uppaal in a nutshell. Int. Journal on Software Tools for Technology Transfer, 1(1–2):134–152, October 1997. 53. Fredrik Larsson, Kim G. Larsen, Paul Pettersson, and Wang Yi. Eÿcient veriﬁcation of real-time systems: Compact data structures and state-space reduction. In Proc. of the 18th IEEE Real-Time Systems Symposium, pages 14–24. IEEE Computer Society Press, December 1997. 54. Magnus Lindahl, Paul Pettersson, and Wang Yi. Formal design and analysis of a gearbox controller. Springer International Journal of Software Tools for Technology Transfer (STTT), 3(3):353–368, 2001. 55. Henrik L¨onn and Paul Pettersson. Formal veriﬁcation of a TDMA protocol startup mechanism. In Proc. of the Paciﬁc Rim Int. Symp. on Fault-Tolerant Systems, pages 235–242, December 1997. 56. Brian Nielsen. Speciﬁcation and Test of Real-Time Systems. PhD thesis, Aalborg University, 2000. 57. Paul Pettersson. Modelling and Veriﬁcation of Real-time Systems Using Timed Automata: Theory and Practice. PhD thesis, Uppsala University, 1999. 58. D.P.L. Simons and M.I.A. Stoelinga. Mechanical veriﬁcation of the IEEE 1394a root contention protocol using Uppaal2k. Springer International Journal of Software Tools for Technology Transfer, pages 469–485, 2001. 59. F.W. Vaandrager and A.L. de Groot. Analysis of a biphase mark protocol with Uppaal and PVS. Technical Report NIII-R0445, Radboud University of Nijmegen, 2004. 60. Wang Yi, Paul Petterson, and Mats Daniels. Automatic veriﬁcation of real-time communicating systems by constraint-solving. In Seventh International Conference on Formal Description Techniques, pages 223–238, 1994. Appendix Expression ! ID | NAT | Expression ’[’ Expression ’]’ | ’(’ Expression ’)’ | Expression ’++’ | ’++’ Expression | Expression ’--’ | ’--’ Expression | Expression AssignOp Expression | UnaryOp Expression | Expression BinaryOp Expression | Expression ’?’ Expression ’:’ Expression | Expression ’.’ ID UnaryOp ! ’-’ | ’!’ | ’not’ BinaryOp ! ’<’ | ’<=’ | ’==’ | ’!=’ | ’>=’ | ’>’ | ’+’ | ’-’ | ’*’ | ’/’ | ’%’ | ’&’ | ’|’ | ’^’ | ’<<’ | ’>>’ | ’&&’ | ’||’ | ’<?’ | ’>?’ | ’and’ | ’or’ | ’imply’ AssignOp ! ’:=’ | ’+=’ | ’-=’ | ’*=’ | ’/=’ | ’%=’ | ’|=’ | ’&=’ | ’^=’ | ’<<=’ | ’>>=’ Fig. 33. Syntax of expressions in BNF. Table 3. Options of verifyta and the corresponding options in the GUI. Defaults of verifyta are shown in boldface. State Space Representation -C DBM Use DBMs rather than a minimal constrain graph [53] in the state representation used to store reachable states. This increases the memory usage (more so in models with many clocks), but is often faster. -A Over approximation Use convex hull over-approximation [7]. For timed systems, this can drastically increase veriﬁcation speed. For untimed systems, this has no e ect. -Z Under approximation Use bit-state hashing under-approximation. This reduces memory consumption to a more of less ﬁxed amount. The precision of the approximation is controlled by changing the hash table size. Known as super-trace in [40,41]. -T Reuse Speed up veriﬁcation by reusing the generated state-space when possible. For some combinations of properties this option can possibly lead to a larger state-space representation, thus nullifying the speedup. -U When representing states with minimal constraint graphs, this option changes how states are compared. It reduces the memory consumption at the expense of a more time consuming comparison operator. The reduced memory usage might cancel out the overhead. In the GUI, this is always on. -H Change the size of hash tables used during veriﬁcation. Can give a speedup for large systems. State Space Reduction -S0 None Store all reachable states. Uses most memory, but avoids that any state is explored more than once. -S1 Conservative Store all non-committed states. Less memory when committed locations are used, and for most models states are only explored once. -S2 Aggressive Try hard to reduce the number of states stored. Uses much less memory, but might take much more time. Do not combine this option with depth ﬁrst search, as the running time increases drastically. Search Order -b Breadth First Search the state space using a breadth ﬁrst strategy. -d Depth First Search the state space using a depth ﬁrst strategy. Trace Options -t0 Some Trace Generate some diagnostic trace. -t1 Shortest Trace Generate the shortest (in number of steps) trace. -t2 Fastest Trace Generate the fastest (smallest time delay) trace. -f Write traces to XTR trace ﬁles (which can be read by the GUI). -y By default concrete traces (showing both delay and control transitions) are produced. This option produces symbolic traces like those shown in the GUI. 